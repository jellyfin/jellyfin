(function (f) {
    function m(b, a, c) { void 0 === b.selectionStart ? (b.focus(), b = b.createTextRange(), b.collapse(!0), b.moveEnd("character", c), b.moveStart("character", a), b.select()) : (b.selectionStart = a, b.selectionEnd = c) } function C(b, a) { f.each(a, function (c, d) { "function" === typeof d ? a[c] = d(b, a, c) : "function" === typeof b.autoNumeric[d] && (a[c] = b.autoNumeric[d](b, a, c)) }) } function p(b, a) { "string" === typeof b[a] && (b[a] *= 1) } function x(b, a) {
        C(b, a); a.oEvent = null; a.tagList = "B CAPTION CITE CODE DD DEL DIV DFN DT EM H1 H2 H3 H4 H5 H6 INS KDB LABEL LI OUTPUT P Q S SAMPLE SPAN STRONG TD TH U VAR".split(" ");
        var c = a.vMax.toString().split("."), d = a.vMin || 0 === a.vMin ? a.vMin.toString().split(".") : []; p(a, "vMax"); p(a, "vMin"); p(a, "mDec"); a.allowLeading = !0; a.aNeg = 0 > a.vMin ? "-" : ""; c[0] = c[0].replace("-", ""); d[0] = d[0].replace("-", ""); a.mInt = Math.max(c[0].length, d[0].length, 1); if (null === a.mDec) { var e = 0, g = 0; c[1] && (e = c[1].length); d[1] && (g = d[1].length); a.mDec = Math.max(e, g) } null === a.altDec && 0 < a.mDec && ("." === a.aDec && "," !== a.aSep ? a.altDec = "," : "," === a.aDec && "." !== a.aSep && (a.altDec = ".")); c = a.aNeg ? "([-\\" + a.aNeg + "]?)" : "(-?)";
        a.aNegRegAutoStrip = c; a.skipFirstAutoStrip = RegExp(c + "[^-" + (a.aNeg ? "\\" + a.aNeg : "") + "\\" + a.aDec + "\\d].*?(\\d|\\" + a.aDec + "\\d)"); a.skipLastAutoStrip = RegExp("(\\d\\" + a.aDec + "?)[^\\" + a.aDec + "\\d]\\D*$"); a.allowedAutoStrip = RegExp("[^" + ("-" + a.aNum + "\\" + a.aDec) + "]", "gi"); a.numRegAutoStrip = RegExp(c + "(?:\\" + a.aDec + "?(\\d+\\" + a.aDec + "\\d+)|(\\d*(?:\\" + a.aDec + "\\d*)?))"); return a
    } function h(b, a, c) {
        if (a.aSign) for (; -1 < b.indexOf(a.aSign) ;) b = b.replace(a.aSign, ""); b = b.replace(a.skipFirstAutoStrip, "$1$2"); b = b.replace(a.skipLastAutoStrip,
        "$1"); b = b.replace(a.allowedAutoStrip, ""); a.altDec && (b = b.replace(a.altDec, a.aDec)); b = (b = b.match(a.numRegAutoStrip)) ? [b[1], b[2], b[3]].join("") : ""; if (("allow" === a.lZero || "keep" === a.lZero) && "strip" !== c) { var d = [], e = "", d = b.split(a.aDec); -1 !== d[0].indexOf("-") && (e = "-", d[0] = d[0].replace("-", "")); d[0].length > a.mInt && "0" === d[0].charAt(0) && (d[0] = d[0].slice(1)); b = e + d.join(a.aDec) } if (c && "deny" === a.lZero || c && "allow" === a.lZero && !1 === a.allowLeading) a = "^" + a.aNegRegAutoStrip + "0*(\\d" + ("leading" === c ? ")" : "|$)"), a = RegExp(a),
        b = b.replace(a, "$1$2"); return b
    } function q(b, a, c) { a = a.split(","); "set" === c || "focusout" === c ? (b = b.replace("-", ""), b = a[0] + b + a[1]) : "get" !== c && "focusin" !== c && "pageLoad" !== c || b.charAt(0) !== a[0] || (b = b.replace(a[0], "-"), b = b.replace(a[1], "")); return b } function y(b, a, c) { if (a && c) { var d = b.split(a); d[1] && d[1].length > c && (0 < c ? (d[1] = d[1].substring(0, c), b = d.join(a)) : b = d[0]) } return b } function s(b, a, c) { a && "." !== a && (b = b.replace(a, ".")); c && "-" !== c && (b = b.replace(c, "-")); b.match(/\d/) || (b += "0"); return b } function z(b, a) {
        var c =
        b.indexOf("."), d = +b; -1 !== c && (1E-6 > d && -1 < d ? (b = +b, 1E-6 > b && 0 < b && (b = (b + 10).toString(), b = b.substring(1)), 0 > b && -1 < b && (b = (b - 10).toString(), b = "-" + b.substring(2)), b = b.toString()) : (c = b.split("."), void 0 !== c[1] && (0 === +c[1] ? b = c[0] : (c[1] = c[1].replace(/0*$/, ""), b = c.join("."))))); return "keep" === a.lZero ? b : b.replace(/^0*(\d)/, "$1")
    } function A(b, a, c) { c && "-" !== c && (b = b.replace("-", c)); a && "." !== a && (b = b.replace(".", a)); return b } function t(b, a) {
        b = h(b, a); b = y(b, a.aDec, a.mDec); b = s(b, a.aDec, a.aNeg); var c = +b; "set" === a.oEvent &&
        (c < a.vMin || c > a.vMax) && f.error("The value (" + c + ") from the 'set' method falls outside of the vMin / vMax range"); return c >= a.vMin && c <= a.vMax
    } function r(b, a, c) { return "" === b || b === a.aNeg ? "zero" === a.wEmpty ? b + "0" : "sign" === a.wEmpty || c ? b + a.aSign : b : null } function u(b, a) {
        b = h(b, a); var c = b.replace(",", "."), d = r(b, a, !0); if (null !== d) return d; var d = "", d = 2 === a.dGroup ? /(\d)((\d)(\d{2}?)+)$/ : 4 === a.dGroup ? /(\d)((\d{4}?)+)$/ : /(\d)((\d{3}?)+)$/, e = b.split(a.aDec); a.altDec && 1 === e.length && (e = b.split(a.altDec)); var g = e[0];
        if (a.aSep) for (; d.test(g) ;) g = g.replace(d, "$1" + a.aSep + "$2"); 0 !== a.mDec && 1 < e.length ? (e[1].length > a.mDec && (e[1] = e[1].substring(0, a.mDec)), b = g + a.aDec + e[1]) : b = g; a.aSign && (d = -1 !== b.indexOf(a.aNeg), b = b.replace(a.aNeg, ""), b = "p" === a.pSign ? a.aSign + b : b + a.aSign, d && (b = a.aNeg + b)); "set" === a.oEvent && 0 > c && null !== a.nBracket && (b = q(b, a.nBracket, a.oEvent)); return b
    } function v(b, a) {
        b = "" === b ? "0" : b.toString(); p(a, "mDec"); var c = "", d = 0, e = "", g = "boolean" === typeof a.aPad || null === a.aPad ? a.aPad ? a.mDec : 0 : +a.aPad, n = function (a) {
            a =
            a.replace(0 === g ? /(\.[1-9]*)0*$/ : 1 === g ? /(\.\d[1-9]*)0*$/ : RegExp("(\\.\\d{" + g + "}[1-9]*)0*$"), "$1"); 0 === g && (a = a.replace(/\.$/, "")); return a
        }; "-" === b.charAt(0) && (e = "-", b = b.replace("-", "")); b.match(/^\d/) || (b = "0" + b); "-" === e && 0 === +b && (e = ""); if (0 < +b && "keep" !== a.lZero || 0 < b.length && "allow" === a.lZero) b = b.replace(/^0*(\d)/, "$1"); var d = b.lastIndexOf("."), f = b.length - 1 - (-1 === d ? b.length - 1 : d); if (f <= a.mDec) {
            c = b; if (f < g) for (-1 === d && (c += ".") ; f < g;) n = "000000".substring(0, g - f), c += n, f += n.length; else f > g ? c = n(c) : 0 === f && 0 ===
            g && (c = c.replace(/\.$/, "")); return e + c
        } var c = d + a.mDec, d = +b.charAt(c + 1), f = b.substring(0, c + 1).split(""), h = "." === b.charAt(c) ? b.charAt(c - 1) % 2 : b.charAt(c) % 2; if (4 < d && "S" === a.mRound || 4 < d && "A" === a.mRound && "" === e || 5 < d && "A" === a.mRound && "-" === e || 5 < d && "s" === a.mRound || 5 < d && "a" === a.mRound && "" === e || 4 < d && "a" === a.mRound && "-" === e || 5 < d && "B" === a.mRound || 5 === d && "B" === a.mRound && 1 === h || 0 < d && "C" === a.mRound && "" === e || 0 < d && "F" === a.mRound && "-" === e || 0 < d && "U" === a.mRound) for (d = f.length - 1; 0 <= d; d -= 1) if ("." !== f[d]) {
            f[d] = +f[d] + 1; if (10 >
            f[d]) break; 0 < d && (f[d] = "0")
        } f = f.slice(0, c + 1); c = n(f.join("")); return 0 === +c ? c : e + c
    } function B(b, a) { this.settings = a; this.that = b; this.$that = f(b); this.formatted = !1; this.settingsClone = x(this.$that, this.settings); this.value = b.value } function l(b) { "string" === typeof b && (b = b.replace(/\[/g, "\\[").replace(/\]/g, "\\]"), b = "#" + b.replace(/(:|\.)/g, "\\$1")); return f(b) } function k(b, a, c) { var d = b.data("autoNumeric"); d || (d = {}, b.data("autoNumeric", d)); var e = d.holder; if (void 0 === e && a || c) e = new B(b.get(0), a), d.holder = e; return e }
    B.prototype = {
        init: function (b) {
            this.value = this.that.value; this.settingsClone = x(this.$that, this.settings); this.ctrlKey = b.ctrlKey; this.cmdKey = b.metaKey; this.shiftKey = b.shiftKey; var a = this.that, c = {}; if (void 0 === a.selectionStart) { a.focus(); var d = document.selection.createRange(); c.length = d.text.length; d.moveStart("character", -a.value.length); c.end = d.text.length; c.start = c.end - c.length } else c.start = a.selectionStart, c.end = a.selectionEnd, c.length = c.end - c.start; this.selection = c; if ("keydown" === b.type || "keyup" ===
            b.type) this.kdCode = b.keyCode; this.which = b.which; this.formatted = this.processed = !1
        }, setSelection: function (b, a, c) { b = Math.max(b, 0); a = Math.min(a, this.that.value.length); this.selection = { start: b, end: a, length: a - b }; (void 0 === c || c) && m(this.that, b, a) }, setPosition: function (b, a) { this.setSelection(b, b, a) }, getBeforeAfter: function () { var b = this.value, a = b.substring(0, this.selection.start), b = b.substring(this.selection.end, b.length); return [a, b] }, getBeforeAfterStriped: function () {
            var b = this.getBeforeAfter(); b[0] = h(b[0],
            this.settingsClone); b[1] = h(b[1], this.settingsClone); return b
        }, normalizeParts: function (b, a) { var c = this.settingsClone; a = h(a, c); var d = a.match(/^\d/) ? !0 : "leading"; b = h(b, c, d); "" !== b && b !== c.aNeg || "deny" !== c.lZero || "" < a && (a = a.replace(/^0*(\d)/, "$1")); d = b + a; if (c.aDec) { var e = d.match(RegExp("^" + c.aNegRegAutoStrip + "\\" + c.aDec)); e && (b = b.replace(e[1], e[1] + "0"), d = b + a) } "zero" !== c.wEmpty || d !== c.aNeg && "" !== d || (b += "0"); return [b, a] }, setValueParts: function (b, a) {
            var c = this.settingsClone, d = this.normalizeParts(b, a), e = d.join(""),
            d = d[0].length; return t(e, c) ? (e = y(e, c.aDec, c.mDec), d > e.length && (d = e.length), this.value = e, this.setPosition(d, !1), !0) : !1
        }, signPosition: function () { var b = this.settingsClone, a = b.aSign, c = this.that; if (a) { a = a.length; if ("p" === b.pSign) return b.aNeg && c.value && c.value.charAt(0) === b.aNeg ? [1, a + 1] : [0, a]; b = c.value.length; return [b - a, b] } return [1E3, -1] }, expandSelectionOnSign: function (b) {
            var a = this.signPosition(), c = this.selection; c.start < a[1] && c.end > a[0] && ((c.start < a[0] || c.end > a[1]) && this.value.substring(Math.max(c.start,
            a[0]), Math.min(c.end, a[1])).match(/^\s*$/) ? c.start < a[0] ? this.setSelection(c.start, a[0], b) : this.setSelection(a[1], c.end, b) : this.setSelection(Math.min(c.start, a[0]), Math.max(c.end, a[1]), b))
        }, checkPaste: function () {
            if (void 0 !== this.valuePartsBeforePaste) {
                var b = this.getBeforeAfter(), a = this.valuePartsBeforePaste; delete this.valuePartsBeforePaste; b[0] = b[0].substr(0, a[0].length) + h(b[0].substr(a[0].length), this.settingsClone); this.setValueParts(b[0], b[1]) || (this.value = a.join(""), this.setPosition(a[0].length,
                !1))
            }
        }, skipAllways: function (b) {
            var a = this.kdCode, c = this.which, d = this.ctrlKey, e = this.cmdKey, f = this.shiftKey; if ((d || e) && "keyup" === b.type && void 0 !== this.valuePartsBeforePaste || f && 45 === a) return this.checkPaste(), !1; if (112 <= a && 123 >= a || 91 <= a && 93 >= a || 9 <= a && 31 >= a || 8 > a && (0 === c || c === a) || 144 === a || 145 === a || 45 === a || (d || e) && 65 === a) return !0; if ((d || e) && (67 === a || 86 === a || 88 === a)) {
                "keydown" === b.type && this.expandSelectionOnSign(); if (86 === a || 45 === a) "keydown" === b.type || "keypress" === b.type ? void 0 === this.valuePartsBeforePaste &&
                (this.valuePartsBeforePaste = this.getBeforeAfter()) : this.checkPaste(); return "keydown" === b.type || "keypress" === b.type || 67 === a
            } return d || e ? !0 : 37 === a || 39 === a ? (c = this.settingsClone.aSep, d = this.selection.start, e = this.that.value, "keydown" === b.type && c && !this.shiftKey && (37 === a && e.charAt(d - 2) === c ? this.setPosition(d - 1) : 39 === a && e.charAt(d + 1) === c && this.setPosition(d + 1)), !0) : 34 <= a && 40 >= a ? !0 : !1
        }, processAllways: function () {
            var b; return 8 === this.kdCode || 46 === this.kdCode ? (this.selection.length ? (this.expandSelectionOnSign(!1),
            b = this.getBeforeAfterStriped()) : (b = this.getBeforeAfterStriped(), 8 === this.kdCode ? b[0] = b[0].substring(0, b[0].length - 1) : b[1] = b[1].substring(1, b[1].length)), this.setValueParts(b[0], b[1]), !0) : !1
        }, processKeypress: function () {
            var b = this.settingsClone, a = String.fromCharCode(this.which), c = this.getBeforeAfterStriped(), d = c[0], c = c[1]; if (a === b.aDec || b.altDec && a === b.altDec || ("." === a || "," === a) && 110 === this.kdCode) {
                if (!b.mDec || !b.aDec || b.aNeg && -1 < c.indexOf(b.aNeg) || -1 < d.indexOf(b.aDec) || 0 < c.indexOf(b.aDec)) return !0;
                0 === c.indexOf(b.aDec) && (c = c.substr(1)); this.setValueParts(d + b.aDec, c); return !0
            } if ("-" === a || "+" === a) { if (!b.aNeg) return !0; "" === d && -1 < c.indexOf(b.aNeg) && (d = b.aNeg, c = c.substring(1, c.length)); d = d.charAt(0) === b.aNeg ? d.substring(1, d.length) : "-" === a ? b.aNeg + d : d; this.setValueParts(d, c); return !0 } "0" <= a && "9" >= a && (b.aNeg && "" === d && -1 < c.indexOf(b.aNeg) && (d = b.aNeg, c = c.substring(1, c.length)), 0 >= b.vMax && b.vMin < b.vMax && -1 === this.value.indexOf(b.aNeg) && "0" !== a && (d = b.aNeg + d), this.setValueParts(d + a, c)); return !0
        }, formatQuick: function () {
            var b =
            this.settingsClone, a = this.getBeforeAfterStriped(), c = this.value; if (("" === b.aSep || "" !== b.aSep && -1 === c.indexOf(b.aSep)) && ("" === b.aSign || "" !== b.aSign && -1 === c.indexOf(b.aSign))) { var d = [], e = "", d = c.split(b.aDec); -1 < d[0].indexOf("-") && (e = "-", d[0] = d[0].replace("-", ""), a[0] = a[0].replace("-", "")); d[0].length > b.mInt && "0" === a[0].charAt(0) && (a[0] = a[0].slice(1)); a[0] = e + a[0] } c = u(this.value, this.settingsClone); d = c.length; if (c) {
                a = a[0].split(""); e = 0; for (e; e < a.length; e += 1) a[e].match("\\d") || (a[e] = "\\" + a[e]); a = RegExp("^.*?" +
                a.join(".*?")); (a = c.match(a)) ? (d = a[0].length, (0 === d && c.charAt(0) !== b.aNeg || 1 === d && c.charAt(0) === b.aNeg) && b.aSign && "p" === b.pSign && (d = this.settingsClone.aSign.length + ("-" === c.charAt(0) ? 1 : 0))) : b.aSign && "s" === b.pSign && (d -= b.aSign.length)
            } this.that.value = c; this.setPosition(d); this.formatted = !0
        }
    }; var w = {
        init: function (b) {
            return this.each(function () {
                var a = f(this), c = a.data("autoNumeric"), d = a.data(); if ("object" !== typeof c) {
                    c = f.extend({}, {
                        aNum: "0123456789", aSep: ",", dGroup: "3", aDec: ".", altDec: null, aSign: "", pSign: "p",
                        vMax: "9999999999999.99", vMin: "0.00", mDec: null, mRound: "S", aPad: !0, nBracket: null, wEmpty: "empty", lZero: "allow", aForm: !0, onSomeEvent: function () { }
                    }, d, b); if (c.aDec === c.aSep) return f.error("autoNumeric will not function properly when the decimal character aDec: '" + c.aDec + "' and thousand separator aSep: '" + c.aSep + "' are the same character"), this; a.data("autoNumeric", c)
                } else return this; c.lastSetValue = ""; c.runOnce = !1; var e = k(a, c); if (-1 === f.inArray(a.prop("tagName"), c.tagList) && "INPUT" !== a.prop("tagName")) return f.error("The <" +
                a.prop("tagName") + "> is not supported by autoNumeric()"), this; !1 === c.runOnce && c.aForm && (a.is("input[type=text], input[type=hidden], input:not([type])") && (d = !0, "" === a[0].value && "empty" === c.wEmpty && (a[0].value = "", d = !1), "" === a[0].value && "sign" === c.wEmpty && (a[0].value = c.aSign, d = !1), d && a.autoNumeric("set", a.val())), -1 !== f.inArray(a.prop("tagName"), c.tagList) && "" !== a.text() && a.autoNumeric("set", a.text())); c.runOnce = !0; a.is("input[type=text], input[type=hidden], input:not([type])") && (a.on("keydown.autoNumeric",
                function (b) { e = k(a); if (e.settings.aDec === e.settings.aSep) return f.error("autoNumeric will not function properly when the decimal character aDec: '" + e.settings.aDec + "' and thousand separator aSep: '" + e.settings.aSep + "' are the same character"), this; if (e.that.readOnly) return e.processed = !0; e.init(b); e.settings.oEvent = "keydown"; if (e.skipAllways(b)) return e.processed = !0; if (e.processAllways()) return e.processed = !0, e.formatQuick(), b.preventDefault(), !1; e.formatted = !1; return !0 }), a.on("keypress.autoNumeric",
                function (b) { var c = k(a), d = c.processed; c.init(b); c.settings.oEvent = "keypress"; if (c.skipAllways(b)) return !0; if (d) return b.preventDefault(), !1; if (c.processAllways() || c.processKeypress()) return c.formatQuick(), b.preventDefault(), !1; c.formatted = !1 }), a.on("keyup.autoNumeric", function (b) {
                    var c = k(a); c.init(b); c.settings.oEvent = "keyup"; b = c.skipAllways(b); c.kdCode = 0; delete c.valuePartsBeforePaste; a[0].value === c.settings.aSign && ("s" === c.settings.pSign ? m(this, 0, 0) : m(this, c.settings.aSign.length, c.settings.aSign.length));
                    if (b || "" === this.value) return !0; c.formatted || c.formatQuick()
                }), a.on("focusin.autoNumeric", function () { var b = k(a); b.settingsClone.oEvent = "focusin"; if (null !== b.settingsClone.nBracket) { var c = a.val(); a.val(q(c, b.settingsClone.nBracket, b.settingsClone.oEvent)) } b.inVal = a.val(); c = r(b.inVal, b.settingsClone, !0); null !== c && (a.val(c), "s" === b.settings.pSign ? m(this, 0, 0) : m(this, b.settings.aSign.length, b.settings.aSign.length)) }), a.on("focusout.autoNumeric", function () {
                    var b = k(a), c = b.settingsClone, d = a.val(), e = d; b.settingsClone.oEvent =
                    "focusout"; var f = ""; "allow" === c.lZero && (c.allowLeading = !1, f = "leading"); "" !== d && (d = h(d, c, f), null === r(d, c) && t(d, c, a[0]) ? (d = s(d, c.aDec, c.aNeg), d = v(d, c), d = A(d, c.aDec, c.aNeg)) : d = ""); f = r(d, c, !1); null === f && (f = u(d, c)); f !== e && a.val(f); f !== b.inVal && (a.change(), delete b.inVal); null !== c.nBracket && 0 > a.autoNumeric("get") && (b.settingsClone.oEvent = "focusout", a.val(q(a.val(), c.nBracket, c.oEvent)))
                }))
            })
        }, destroy: function () { return f(this).each(function () { var b = f(this); b.off(".autoNumeric"); b.removeData("autoNumeric") }) },
        update: function (b) {
            return f(this).each(function () {
                var a = l(f(this)), c = a.data("autoNumeric"); if ("object" !== typeof c) return f.error("You must initialize autoNumeric('init', {options}) prior to calling the 'update' method"), this; var d = a.autoNumeric("get"), c = f.extend(c, b); k(a, c, !0); if (c.aDec === c.aSep) return f.error("autoNumeric will not function properly when the decimal character aDec: '" + c.aDec + "' and thousand separator aSep: '" + c.aSep + "' are the same character"), this; a.data("autoNumeric", c); if ("" !==
                a.val() || "" !== a.text()) return a.autoNumeric("set", d)
            })
        }, set: function (b) {
            return f(this).each(function () {
                var a = l(f(this)), c = a.data("autoNumeric"), d = b.toString(), e = b.toString(); if ("object" !== typeof c) return f.error("You must initialize autoNumeric('init', {options}) prior to calling the 'set' method"), this; e !== a.attr("value") && e !== a.text() || !1 !== c.runOnce || (d = d.replace(",", ".")); e !== a.attr("value") && "INPUT" === a.prop("tagName") && !1 === c.runOnce && (d = h(d, c)); if (!f.isNumeric(+d)) return ""; d = z(d, c); c.oEvent =
                "set"; c.lastSetValue = d; d.toString(); "" !== d && (d = v(d, c)); d = A(d, c.aDec, c.aNeg); t(d, c) || (d = v("", c)); d = u(d, c); if (a.is("input[type=text], input[type=hidden], input:not([type])")) return a.val(d); if (-1 !== f.inArray(a.prop("tagName"), c.tagList)) return a.text(d); f.error("The <" + a.prop("tagName") + "> is not supported by autoNumeric()"); return !1
            })
        }, get: function () {
            var b = l(f(this)), a = b.data("autoNumeric"); if ("object" !== typeof a) return f.error("You must initialize autoNumeric('init', {options}) prior to calling the 'get' method"),
            this; a.oEvent = "get"; var c = ""; if (b.is("input[type=text], input[type=hidden], input:not([type])")) c = b.eq(0).val(); else if (-1 !== f.inArray(b.prop("tagName"), a.tagList)) c = b.eq(0).text(); else return f.error("The <" + b.prop("tagName") + "> is not supported by autoNumeric()"), !1; if ("" === c && "empty" === a.wEmpty || c === a.aSign && ("sign" === a.wEmpty || "empty" === a.wEmpty)) return ""; null !== a.nBracket && "" !== c && (c = q(c, a.nBracket, a.oEvent)); if (a.runOnce || !1 === a.aForm) c = h(c, a); c = s(c, a.aDec, a.aNeg); 0 === +c && "keep" !== a.lZero &&
            (c = "0"); return "keep" === a.lZero ? c : c = z(c, a)
        }, getString: function () {
            var b = !1, a = l(f(this)).serialize().split("&"), c = 0; for (c; c < a.length; c += 1) { var d = a[c].split("="); "object" === typeof f('*[name="' + decodeURIComponent(d[0]) + '"]').data("autoNumeric") && null !== d[1] && void 0 !== f('*[name="' + decodeURIComponent(d[0]) + '"]').data("autoNumeric") && (d[1] = f('input[name="' + decodeURIComponent(d[0]) + '"]').autoNumeric("get"), a[c] = d.join("="), b = !0) } if (!0 === b) return a.join("&"); f.error("You must initialize autoNumeric('init', {options}) prior to calling the 'getString' method");
            return this
        }, getArray: function () { var b = !1, a = l(f(this)).serializeArray(); f.each(a, function (a, d) { "object" === typeof f('*[name="' + decodeURIComponent(d.name) + '"]').data("autoNumeric") && ("" !== d.value && void 0 !== f('*[name="' + decodeURIComponent(d.name) + '"]').data("autoNumeric") && (d.value = f('input[name="' + decodeURIComponent(d.name) + '"]').autoNumeric("get").toString()), b = !0) }); if (!0 === b) return a; f.error("You must initialize autoNumeric('init', {options}) prior to calling the 'getArray' method"); return this },
        getSettings: function () { return l(f(this)).eq(0).data("autoNumeric") }
    }; f.fn.autoNumeric = function (b) { if (w[b]) return w[b].apply(this, Array.prototype.slice.call(arguments, 1)); if ("object" === typeof b || !b) return w.init.apply(this, arguments); f.error('Method "' + b + '" is not supported by autoNumeric()') }
})(jQuery);