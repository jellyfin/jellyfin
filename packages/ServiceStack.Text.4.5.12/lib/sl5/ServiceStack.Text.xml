<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ServiceStack.Text</name>
    </assembly>
    <members>
        <member name="T:ServiceStack.Text.AssemblyUtils">
            <summary>
            Utils to load types
            </summary>
        </member>
        <member name="M:ServiceStack.Text.AssemblyUtils.FindType(System.String)">
            <summary>
            Find the type from the name supplied
            </summary>
            <param name="typeName">[typeName] or [typeName, assemblyName]</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.AssemblyUtils.MainInterface``1">
            <summary>
            The top-most interface of the given type, if any.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.AssemblyUtils.FindType(System.String,System.String)">
            <summary>
            Find type if it exists
            </summary>
            <param name="typeName"></param>
            <param name="assemblyName"></param>
            <returns>The type if it exists</returns>
        </member>
        <member name="T:ServiceStack.Text.ConcurrentDictionaryKey`2">
            <summary>
            Search key structure for <see cref="T:ServiceStack.Text.ConcurrentDictionary`2"/>
            </summary>
            <typeparam name="TKey">Type of the key.</typeparam>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="T:ServiceStack.Text.ConcurrentDictionary`2">
            <summary>
            A Concurrent <see cref="T:System.Collections.Generic.IDictionary`2"/> implementation.
            </summary>
            <typeparam name="TKey">Type of the keys.</typeparam>
            <typeparam name="TValue">Type of the values.</typeparam>
            <remarks>
            This class is threadsafe and highly concurrent. This means that multiple threads can do lookup and insert operations
            on this dictionary simultaneously. 
            It is not guaranteed that collisions will not occur. The dictionary is partitioned in segments. A segment contains
            a set of items based on a hash of those items. The more segments there are and the beter the hash, the fewer collisions will occur.
            This means that a nearly empty ConcurrentDictionary is not as concurrent as one containing many items. 
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.#ctor">
            <summary>
            Constructs a <see cref="T:ServiceStack.Text.ConcurrentDictionary`2"/> instance using the default <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Constructs a <see cref="T:ServiceStack.Text.ConcurrentDictionary`2"/> instance using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare keys.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> tp compare keys with.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="comparer"/> is null.</exception>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentDictionary`2.Comparer">
            <summary>
            Gives the <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> of TKey that is used to compare keys.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.GetItemHashCode(System.Nullable{System.Collections.Generic.KeyValuePair{`0,`1}}@)">
            <summary>
            Get a hashcode for given storeable item.
            </summary>
            <param name="item">Reference to the item to get a hash value for.</param>
            <returns>The hash value as an <see cref="T:System.UInt32"/>.</returns>
            <remarks>
            The hash returned should be properly randomized hash. The standard GetItemHashCode methods are usually not good enough.
            A storeable item and a matching search key should return the same hash code.
            So the statement <code>ItemEqualsItem(storeableItem, searchKey) ? GetItemHashCode(storeableItem) == GetItemHashCode(searchKey) : true </code> should always be true;
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.GetKeyHashCode(ServiceStack.Text.ConcurrentDictionaryKey{`0,`1}@)">
            <summary>
            Get a hashcode for given search key.
            </summary>
            <param name="key">Reference to the key to get a hash value for.</param>
            <returns>The hash value as an <see cref="T:System.UInt32"/>.</returns>
            <remarks>
            The hash returned should be properly randomized hash. The standard GetItemHashCode methods are usually not good enough.
            A storeable item and a matching search key should return the same hash code.
            So the statement <code>ItemEqualsItem(storeableItem, searchKey) ? GetItemHashCode(storeableItem) == GetItemHashCode(searchKey) : true </code> should always be true;
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.ItemEqualsKey(System.Nullable{System.Collections.Generic.KeyValuePair{`0,`1}}@,ServiceStack.Text.ConcurrentDictionaryKey{`0,`1}@)">
            <summary>
            Compares a storeable item to a search key. Should return true if they match.
            </summary>
            <param name="item">Reference to the storeable item to compare.</param>
            <param name="key">Reference to the search key to compare.</param>
            <returns>True if the storeable item and search key match; false otherwise.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.ItemEqualsItem(System.Nullable{System.Collections.Generic.KeyValuePair{`0,`1}}@,System.Nullable{System.Collections.Generic.KeyValuePair{`0,`1}}@)">
            <summary>
            Compares two storeable items for equality.
            </summary>
            <param name="item1">Reference to the first storeable item to compare.</param>
            <param name="item2">Reference to the second storeable item to compare.</param>
            <returns>True if the two soreable items should be regarded as equal.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.IsEmpty(System.Nullable{System.Collections.Generic.KeyValuePair{`0,`1}}@)">
            <summary>
            Indicates if a specific item reference contains a valid item.
            </summary>
            <param name="item">The storeable item reference to check.</param>
            <returns>True if the reference doesn't refer to a valid item; false otherwise.</returns>
            <remarks>The statement <code>IsEmpty(default(TStoredI))</code> should always be true.</remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the dictionary.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the dictionary.</exception>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.ContainsKey(`0)">
            <summary>
            Determines whether the dictionary
            contains an element with the specified key.
            </summary>
            <param name="key">The key to locate in the dictionary.</param>
            <returns>true if the dictionary contains
            an element with the key; otherwise, false.</returns>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentDictionary`2.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/>  containing the keys of
            the dictionary.           
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the dictionary.</returns>
            <remarks>This property takes a snapshot of the current keys collection of the dictionary at the moment of invocation.</remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.System#Collections#Generic#IDictionary{TKey,TValue}#Remove(`0)">
            <summary>
            Removes the element with the specified key from the dictionary.
            </summary>
            <param name="key">The key of the element to remove.</param>
            <returns>true if the element is successfully removed; otherwise, false. This method
            also returns false if key was not found in the original dictionary.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.TryGetValue(`0,`1@)">
             <summary>
             Gets the value associated with the specified key.
             </summary>
             <param name="key">The key whose value to get.</param>
             <param name="value">
             When this method returns, the value associated with the specified key, if
             the key is found; otherwise, the default value for the type of the value
             parameter. This parameter is passed uninitialized.
            </param>
             <returns>
             true if the dictionary contains an element with the specified key; otherwise, false.
             </returns>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentDictionary`2.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in
                the dictionary.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the dictionary.
            </returns>
            <remarks>This property takes a snapshot of the current keys collection of the dictionary at the moment of invocation.</remarks>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentDictionary`2.Item(`0)">
            <summary>
            Gets or sets the value associated with the specified key.
            </summary>
            <param name="key">The key of the value to get or set.</param>
            <returns>The value associated with the specified key. If the specified key is not found, a get operation throws a KeyNotFoundException, and a set operation creates a new element with the specified key.</returns>
            <remarks>
            When working with multiple threads, that can each potentialy remove the searched for item, a <see cref="T:System.Collections.Generic.KeyNotFoundException"/> can always be expected.
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an association to the dictionary.
            </summary>
            <param name="item">A <see cref="T:System.Collections.Generic.KeyValuePair`2"/> that represents the association to add.</param>
            <exception cref="T:System.ArgumentException">An association with an equal key already exists in the dicitonary.</exception>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.Clear">
            <summary>
            Removes all items from the dictionary.
            </summary>
            <remarks>WHen working with multiple threads, that each can add items to this dictionary, it is not guaranteed that the dictionary will be empty when this method returns.</remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether the specified association exists in the dictionary.
            </summary>
            <param name="item">The key-value association to search fo in the dicionary.</param>
            <returns>True if item is found in the dictionary; otherwise, false.</returns>
            <remarks>
            This method compares both key and value. It uses the default equality comparer to compare values.
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies all associations of the dictionary to an
               <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the associations
                copied from <see cref="T:ServiceStack.Text.ConcurrentDictionaryKey`2"/>. The <see cref="T:System.Array"/> must
                have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="array"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="arrayIndex"/> is less than 0.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.</exception>
            <exception cref="T:System.ArgumentException">The number of associations to be copied
            is greater than the available space from <paramref name="arrayIndex"/> to the end of the destination
            <paramref name="array"/>.</exception>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentDictionary`2.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:ServiceStack.Text.ConcurrentDictionaryKey`2"/>.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:ServiceStack.Text.ConcurrentDictionaryKey`2"/> is read-only, which is always false.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
             <summary>
             Removes the specified association from the <see cref="T:ServiceStack.Text.ConcurrentDictionaryKey`2"/>, comparing both key and value.
             </summary>
             <param name="item">A <see cref="T:System.Collections.Generic.KeyValuePair`2"/> representing the association to remove.</param>
             <returns>true if the association was successfully removed from the <see cref="T:ServiceStack.Text.ConcurrentDictionaryKey`2"/>;
             otherwise, false. This method also returns false if the association is not found in
             the original <see cref="T:ServiceStack.Text.ConcurrentDictionaryKey`2"/>.
            </returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through all associations in the <see cref="T:ServiceStack.Text.ConcurrentDictionaryKey`2"/> at the moment of invocation.
            </summary>
            <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the associations.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through all associations in the <see cref="T:ServiceStack.Text.ConcurrentDictionaryKey`2"/> at the moment of invocation.
            </summary>
            <returns>A <see cref="T:System.Collections.IEnumerator"/> that can be used to iterate through the associations.</returns>
        </member>
        <member name="T:ServiceStack.Text.ConcurrentHashtable`2">
            <summary>
            Base class for concurrent hashtable implementations
            </summary>
            <typeparam name="TStored">Type of the items stored in the hashtable.</typeparam>
            <typeparam name="TSearch">Type of the key to search with.</typeparam>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.#ctor">
            <summary>
            Constructor (protected)
            </summary>
            <remarks>Use Initialize method after construction.</remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.Initialize">
            <summary>
            Initialize the newly created ConcurrentHashtable. Invoke in final (sealed) constructor
            or Create method.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.CreateSegmentRange(System.Int32,System.Int32)">
            <summary>
            Create a segment range
            </summary>
            <param name="segmentCount">Number of segments in range.</param>
            <param name="initialSegmentSize">Number of slots allocated initialy in each segment.</param>
            <returns>The created <see cref="T:ServiceStack.Text.Segmentrange`2"/> instance.</returns>
        </member>
        <member name="F:ServiceStack.Text.ConcurrentHashtable`2._NewRange">
            <summary>
            While adjusting the segmentation, _NewRange will hold a reference to the new range of segments.
            when the adjustment is complete this reference will be copied to _CurrentRange.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.ConcurrentHashtable`2._CurrentRange">
            <summary>
            Will hold the most current reange of segments. When busy adjusting the segmentation, this
            field will hold a reference to the old range.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.ConcurrentHashtable`2._SwitchPoint">
            <summary>
            While adjusting the segmentation this field will hold a boundary.
            Clients accessing items with a key hash value below this boundary (unsigned compared)
            will access _NewRange. The others will access _CurrentRange
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.GetItemHashCode(`0@)">
            <summary>
            Get a hashcode for given storeable item.
            </summary>
            <param name="item">Reference to the item to get a hash value for.</param>
            <returns>The hash value as an <see cref="T:System.UInt32"/>.</returns>
            <remarks>
            The hash returned should be properly randomized hash. The standard GetItemHashCode methods are usually not good enough.
            A storeable item and a matching search key should return the same hash code.
            So the statement <code>ItemEqualsItem(storeableItem, searchKey) ? GetItemHashCode(storeableItem) == GetItemHashCode(searchKey) : true </code> should always be true;
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.GetKeyHashCode(`1@)">
            <summary>
            Get a hashcode for given search key.
            </summary>
            <param name="key">Reference to the key to get a hash value for.</param>
            <returns>The hash value as an <see cref="T:System.UInt32"/>.</returns>
            <remarks>
            The hash returned should be properly randomized hash. The standard GetItemHashCode methods are usually not good enough.
            A storeable item and a matching search key should return the same hash code.
            So the statement <code>ItemEqualsItem(storeableItem, searchKey) ? GetItemHashCode(storeableItem) == GetItemHashCode(searchKey) : true </code> should always be true;
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.ItemEqualsKey(`0@,`1@)">
            <summary>
            Compares a storeable item to a search key. Should return true if they match.
            </summary>
            <param name="item">Reference to the storeable item to compare.</param>
            <param name="key">Reference to the search key to compare.</param>
            <returns>True if the storeable item and search key match; false otherwise.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.ItemEqualsItem(`0@,`0@)">
            <summary>
            Compares two storeable items for equality.
            </summary>
            <param name="item1">Reference to the first storeable item to compare.</param>
            <param name="item2">Reference to the second storeable item to compare.</param>
            <returns>True if the two soreable items should be regarded as equal.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.IsEmpty(`0@)">
            <summary>
            Indicates if a specific item reference contains a valid item.
            </summary>
            <param name="item">The storeable item reference to check.</param>
            <returns>True if the reference doesn't refer to a valid item; false otherwise.</returns>
            <remarks>The statement <code>IsEmpty(default(TStoredI))</code> should always be true.</remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.GetKeyType(`0@)">
            <summary>
            Returns the type of the key value or object.
            </summary>
            <param name="item">The stored item to get the type of the key for.</param>
            <returns>The actual type of the key or null if it can not be determined.</returns>
            <remarks>
            Used for diagnostics purposes.
            </remarks>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentHashtable`2.SyncRoot">
            <summary>
            Returns an object that serves as a lock for range operations 
            </summary>
            <remarks>
            Clients use this primarily for enumerating over the Tables contents.
            Locking doesn't guarantee that the contents don't change, but prevents operations that would
            disrupt the enumeration process.
            Operations that use this lock:
            Count, Clear, DisposeGarbage and AssessSegmentation.
            Keeping this lock will prevent the table from re-segmenting.
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.GetSegment(System.UInt32)">
            <summary>
            Gets a segment out of either _NewRange or _CurrentRange based on the hash value.
            </summary>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.GetSegmentLockedForWriting(System.UInt32)">
            <summary>
            Gets a LOCKED segment out of either _NewRange or _CurrentRange based on the hash value.
            Unlock needs to be called on this segment before it can be used by other clients.
            </summary>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.GetSegmentLockedForReading(System.UInt32)">
            <summary>
            Gets a LOCKED segment out of either _NewRange or _CurrentRange based on the hash value.
            Unlock needs to be called on this segment before it can be used by other clients.
            </summary>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.FindItem(`1@,`0@)">
            <summary>
            Finds an item in the table collection that maches the given searchKey
            </summary>
            <param name="searchKey">The key to the item.</param>
            <param name="item">Out reference to a field that will receive the found item.</param>
            <returns>A boolean that will be true if an item has been found and false otherwise.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.GetOldestItem(`0@,`0@)">
            <summary>
            Looks for an existing item in the table contents using an alternative copy. If it can be found it will be returned. 
            If not then the alternative copy will be added to the table contents and the alternative copy will be returned.
            </summary>
            <param name="searchKey">A copy to search an already existing instance with</param>
            <param name="item">Out reference to receive the found item or the alternative copy</param>
            <returns>A boolean that will be true if an existing copy was found and false otherwise.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.ReplaceItem(`1@,`0@,`0@,System.Func{`0,System.Boolean})">
            <summary>
            Replaces and existing item
            </summary>
            <param name="newItem"></param>
            <param name="oldItem"></param>
            <param name="sanction"></param>
            <returns>true is the existing item was successfully replaced.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.InsertItem(`0@,`0@)">
            <summary>
            Inserts an item in the table contents possibly replacing an existing item.
            </summary>
            <param name="searchKey">The item to insert in the table</param>
            <param name="replacedItem">Out reference to a field that will receive any possibly replaced item.</param>
            <returns>A boolean that will be true if an existing copy was found and replaced and false otherwise.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.RemoveItem(`1@,`0@)">
            <summary>
            Removes an item from the table contents.
            </summary>
            <param name="searchKey">The key to find the item with.</param>
            <param name="removedItem">Out reference to a field that will receive the found and removed item.</param>
            <returns>A boolean that will be rue if an item was found and removed and false otherwise.</returns>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.EnumerateAmorphLockedSegments(System.Boolean)">
            <summary>
            Enumerates all segments in _CurrentRange and locking them before yielding them and resleasing the lock afterwards
            The order in which the segments are returned is undefined.
            Lock SyncRoot before using this enumerable.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentHashtable`2.Items">
            <summary>
            Gets an IEnumerable to iterate over all items in all segments.
            </summary>
            <returns></returns>
            <remarks>
            A lock should be aquired and held on SyncRoot while this IEnumerable is being used.
            The order in which the items are returned is undetermined.
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.Clear">
            <summary>
            Removes all items from the collection. 
            Aquires a lock on SyncRoot before it does it's thing.
            When this method returns and multiple threads have access to this table it
            is not guaranteed that the table is actually empty.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentHashtable`2.Count">
            <summary>
            Returns a count of all items in teh collection. This may not be
            aqurate when multiple threads are accessing this table.
            Aquires a lock on SyncRoot before it does it's thing.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentHashtable`2.MinSegments">
            <summary>
            Gives the minimum number of segments a hashtable can contain. This should be 1 or more and always a power of 2.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentHashtable`2.MinSegmentAllocatedSpace">
            <summary>
            Gives the minimum number of allocated item slots per segment. This should be 1 or more, always a power of 2
            and less than 1/2 of MeanSegmentAllocatedSpace.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.ConcurrentHashtable`2.MeanSegmentAllocatedSpace">
            <summary>
            Gives the prefered number of allocated item slots per segment. This should be 4 or more and always a power of 2.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.SegmentationAdjustmentNeeded">
            <summary>
            Determines if a segmentation adjustment is needed.
            </summary>
            <returns>True</returns>
        </member>
        <member name="F:ServiceStack.Text.ConcurrentHashtable`2._AssessSegmentationPending">
            <summary>
            Bool as int (for interlocked functions) that is true if a Segmentation assesment is pending.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.ConcurrentHashtable`2._AllocatedSpace">
            <summary>
            The total allocated number of item slots. Filled with nonempty items or not.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.EffectTotalAllocatedSpace(System.Int32)">
            <summary>
            When a segment resizes it uses this method to inform the hashtable of the change in allocated space.
            </summary>
            <param name="effect"></param>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.ScheduleMaintenance">
            <summary>
            Schedule a call to the AssessSegmentation() method.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.AssessSegmentation(System.Object)">
            <summary>
            Checks if segmentation needs to be adjusted and if so performs the adjustment.
            </summary>
            <param name="dummy"></param>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.AssessSegmentation">
            <summary>
            This method is called when a re-segmentation is expected to be needed. It checks if it actually is needed and, if so, performs the re-segementation.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ConcurrentHashtable`2.SetSegmentation(System.Int32,System.Int32)">
            <summary>
            Adjusts the segmentation to the new segment count
            </summary>
            <param name="newSegmentCount">The new number of segments to use. This must be a power of 2.</param>
            <param name="segmentSize">The number of item slots to reserve in each segment.</param>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.Initialize(System.Int32)">
            <summary>
            Initialize the segment.
            </summary>
            <param name="initialSize"></param>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.Welcome(ServiceStack.Text.ConcurrentHashtable{`0,`1})">
            <summary>
            When segment gets introduced into hashtable then its allocated space should be added to the
            total allocated space.
            Single threaded access or locking is needed
            </summary>
            <param name="traits"></param>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.Bye(ServiceStack.Text.ConcurrentHashtable{`0,`1})">
            <summary>
            When segment gets removed from hashtable then its allocated space should be subtracted to the
            total allocated space.
            Single threaded access or locking is needed
            </summary>
            <param name="traits"></param>
        </member>
        <member name="F:ServiceStack.Text.Segment`2._List">
            <summary>
            Array with 'slots'. Each slot can be filled or empty.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.Segment`2.IsAlive">
            <summary>
            Boolean value indicating if this segment has not been trashed yet.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.InsertItemAtIndex(System.UInt32,System.UInt32,`0,ServiceStack.Text.ConcurrentHashtable{`0,`1})">
            <summary>
            Inserts an item into a *not empty* spot given by position i. It moves items forward until an empty spot is found.
            </summary>
            <param name="mask"></param>
            <param name="i"></param>
            <param name="itemCopy"></param>
            <param name="traits"></param>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.FindItem(`1@,`0@,ServiceStack.Text.ConcurrentHashtable{`0,`1})">
            <summary>
            Find item in segment.
            </summary>
            <param name="key">Reference to the search key to use.</param>
            <param name="item">Out reference to store the found item in.</param>
            <param name="traits">Object that tells this segment how to treat items and keys.</param>
            <returns>True if an item could be found, otherwise false.</returns>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.GetOldestItem(`0@,`0@,ServiceStack.Text.ConcurrentHashtable{`0,`1})">
            <summary>
            Find an existing item or, if it can't be found, insert a new item.
            </summary>
            <param name="key">Reference to the item that will be inserted if an existing item can't be found. It will also be used to search with.</param>
            <param name="item">Out reference to store the found item or, if it can not be found, the new inserted item.</param>
            <param name="traits">Object that tells this segment how to treat items and keys.</param>
            <returns>True if an existing item could be found, otherwise false.</returns>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.InsertItem(`0@,`0@,ServiceStack.Text.ConcurrentHashtable{`0,`1})">
            <summary>
            Inserts an item in the segment, possibly replacing an equal existing item.
            </summary>
            <param name="key">A reference to the item to insert.</param>
            <param name="item">An out reference where any replaced item will be written to, if no item was replaced the new item will be written to this reference.</param>
            <param name="traits">Object that tells this segment how to treat items and keys.</param>
            <returns>True if an existing item could be found and is replaced, otherwise false.</returns>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.RemoveItem(`1@,`0@,ServiceStack.Text.ConcurrentHashtable{`0,`1})">
            <summary>
            Removes an item from the segment.
            </summary>
            <param name="key">A reference to the key to search with.</param>
            <param name="item">An out reference where the removed item will be stored or default(<typeparamref name="TStored"/>) if no item to remove can be found.</param>
            <param name="traits">Object that tells this segment how to treat items and keys.</param>
            <returns>True if an item could be found and is removed, false otherwise.</returns>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.GetNextItem(System.Int32,`0@,ServiceStack.Text.ConcurrentHashtable{`0,`1})">
            <summary>
            Iterate over items in the segment. 
            </summary>
            <param name="beyond">Position beyond which the next filled slot will be found and the item in that slot returned. (Starting with -1)</param>
            <param name="item">Out reference where the next item will be stored or default if the end of the segment is reached.</param>
            <param name="traits">Object that tells this segment how to treat items and keys.</param>
            <returns>The index position the next item has been found or -1 otherwise.</returns>
        </member>
        <member name="F:ServiceStack.Text.Segment`2._Count">
            <summary>
            Total numer of filled slots in _List.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Segment`2.Trim(ServiceStack.Text.ConcurrentHashtable{`0,`1})">
            <summary>
            Remove any excess allocated space
            </summary>
            <param name="traits"></param>
        </member>
        <member name="M:ServiceStack.Text.TinyReaderWriterLock.ReleaseForReading">
            <summary>
            Release a reader lock
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TinyReaderWriterLock.ReleaseForWriting">
            <summary>
            Release a writer lock
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TinyReaderWriterLock.LockForReading">
            <summary>
            Aquire a reader lock. Wait until lock is aquired.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TinyReaderWriterLock.LockForReading(System.Boolean)">
            <summary>
            Aquire a reader lock.
            </summary>
            <param name="wait">True if to wait until lock aquired, False to return immediately.</param>
            <returns>Boolean indicating if lock was successfuly aquired.</returns>
        </member>
        <member name="M:ServiceStack.Text.TinyReaderWriterLock.LockForWriting">
            <summary>
            Aquire a writer lock. Wait until lock is aquired.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TinyReaderWriterLock.LockForWriting(System.Boolean)">
            <summary>
            Aquire a writer lock.
            </summary>
            <param name="wait">True if to wait until lock aquired, False to return immediately.</param>
            <returns>Boolean indicating if lock was successfuly aquired.</returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DateTimeSerializer.Prepare(System.DateTime,System.Boolean)">
            <summary>
            If AlwaysUseUtc is set to true then convert all DateTime to UTC. If PreserveUtc is set to true then UTC dates will not convert to local
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DateTimeSerializer.RepairXsdTimeSeparator(System.String)">
            <summary>
            Repairs an out-of-spec XML date/time string which incorrectly uses a space instead of a 'T' to separate the date from the time.
            These string are occasionally generated by SQLite and can cause errors in OrmLite when reading these columns from the DB.
            </summary>
            <param name="dateTimeStr">The XML date/time string to repair</param>
            <returns>The repaired string. If no repairs were made, the original string is returned.</returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DateTimeSerializer.ParseWcfJsonDateOffset(System.String)">
            <summary>
            WCF Json format: /Date(unixts+0000)/
            </summary>
            <param name="wcfJsonDate"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DateTimeSerializer.ParseWcfJsonDate(System.String)">
            <summary>
            WCF Json format: /Date(unixts+0000)/
            </summary>
            <param name="wcfJsonDate"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DeserializeTypeUtils.GetTypeStringConstructor(System.Type)">
            <summary>
            Get the type(string) constructor if exists
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Common.JsWriter.HasAnyEscapeChars(System.String)">
            <summary>
            micro optimizations: using flags instead of value.IndexOfAny(EscapeChars)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.Text.Controller.PathInfo">
            <summary>
            Class to hold  
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ServiceStack.Text.Controller.PathInfo.Parse(System.String)" -->
        <member name="T:ServiceStack.Text.DateTimeExtensions">
            <summary>
            A fast, standards-based, serialization-issue free DateTime serailizer.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.CanCreateFromString(System.Type)">
            <summary>
            Determines whether this serializer can create the specified type from a string.
            </summary>
            <param name="type">The type.</param>
            <returns>
            	<c>true</c> if this instance [can create from string] the specified type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.DeserializeFromString(System.String)">
            <summary>
            Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.DeserializeFromReader(System.IO.TextReader)">
            <summary>
            Deserializes from reader.
            </summary>
            <param name="reader">The reader.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.SerializeToString(`0)">
            <summary>
            Serializes to string.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.SerializeToWriter(`0,System.IO.TextWriter)">
            <summary>
            Serializes to writer.
            </summary>
            <param name="value">The value.</param>
            <param name="writer">The writer.</param>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sTimeSpanHandler">
            <summary>
            Sets which format to use when serializing TimeSpans
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sEmitCamelCaseNames">
            <summary>
            <see langword="true"/> if the <see cref="T:ServiceStack.Text.Common.ITypeSerializer"/> is configured
            to take advantage of <see cref="T:System.CLSCompliantAttribute"/> specification,
            to support user-friendly serialized formats, ie emitting camelCasing for JSON
            and parsing member names and enum values in a case-insensitive manner.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sEmitLowercaseUnderscoreNames">
            <summary>
            <see langword="true"/> if the <see cref="T:ServiceStack.Text.Common.ITypeSerializer"/> is configured
            to support web-friendly serialized formats, ie emitting lowercase_underscore_casing for JSON
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sPropertyConvention">
            <summary>
            Define how property names are mapped during deserialization
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sThrowOnDeserializationError">
            <summary>
            Gets or sets a value indicating if the framework should throw serialization exceptions
            or continue regardless of deserialization errors. If <see langword="true"/>  the framework
            will throw; otherwise, it will parse as many fields as possible. The default is <see langword="false"/>.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sAlwaysUseUtc">
            <summary>
            Gets or sets a value indicating if the framework should always convert <see cref="T:System.DateTime"/> to UTC format instead of local time. 
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sSkipDateTimeConversion">
            <summary>
            Gets or sets a value indicating if the framework should skip automatic <see cref="T:System.DateTime"/> conversions.
            Dates will be handled literally, any included timezone encoding will be lost and the date will be treaded as DateTimeKind.Local
            Utc formatted input will result in DateTimeKind.Utc output. Any input without TZ data will be set DateTimeKind.Unspecified
            This will take precedence over other flags like AlwaysUseUtc 
            JsConfig.DateHandler = DateHandler.ISO8601 should be used when set true for consistent de/serialization.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sAssumeUtc">
            <summary>
            Gets or sets a value indicating if the framework should always assume <see cref="T:System.DateTime"/> is in UTC format if Kind is Unspecified. 
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sAppendUtcOffset">
            <summary>
            Gets or sets whether we should append the Utc offset when we serialize Utc dates. Defaults to no.
            Only supported for when the JsConfig.DateHandler == JsonDateHandler.TimestampOffset
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sEscapeUnicode">
            <summary>
            Gets or sets a value indicating if unicode symbols should be serialized as "\uXXXX".
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sEscapeHtmlChars">
            <summary>
            Gets or sets a value indicating if HTML entity chars [&gt; &lt; &amp; = '] should be escaped as "\uXXXX".
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sOnDeserializationError">
            <summary>
            Gets or sets a value indicating if the framework should call an error handler when
            an exception happens during the deserialization.
            </summary>
            <remarks>Parameters have following meaning in order: deserialized entity, property name, parsed value, property type, caught exception.</remarks>
        </member>
        <member name="P:ServiceStack.Text.JsConfig.PreferInterfaces">
            <summary>
            If set to true, Interface types will be prefered over concrete types when serializing.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sIncludePublicFields">
            <summary>
            If set to true, Interface types will be prefered over concrete types when serializing.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sMaxDepth">
            <summary>
            Sets the maximum depth to avoid circular dependencies
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sModelFactory">
            <summary>
            Set this to enable your own type construction provider.
            This is helpful for integration with IoC containers where you need to call the container constructor.
            Return null if you don't know how to construct the type and the parameterless constructor will be used.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.IncludeTypeInfo">
            <summary>
            Always emit type info for this type.  Takes precedence over ExcludeTypeInfo
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.ExcludeTypeInfo">
            <summary>
            Never emit type info for this type
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.EmitCamelCaseNames">
            <summary>
            <see langword="true"/> if the <see cref="T:ServiceStack.Text.Common.ITypeSerializer"/> is configured
            to take advantage of <see cref="T:System.CLSCompliantAttribute"/> specification,
            to support user-friendly serialized formats, ie emitting camelCasing for JSON
            and parsing member names and enum values in a case-insensitive manner.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.serializeFn">
            <summary>
            Define custom serialization fn for BCL Structs
            </summary>
        </member>
        <member name="P:ServiceStack.Text.JsConfig`1.TreatValueAsRefType">
            <summary>
            Opt-in flag to set some Value Types to be treated as a Ref Type
            </summary>
        </member>
        <member name="P:ServiceStack.Text.JsConfig`1.HasSerializeFn">
            <summary>
            Whether there is a fn (raw or otherwise)
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.rawSerializeFn">
            <summary>
            Define custom raw serialization fn
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.onSerializingFn">
            <summary>
            Define custom serialization hook
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.onSerializedFn">
            <summary>
            Define custom after serialization hook
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.deSerializeFn">
            <summary>
            Define custom deserialization fn for BCL Structs
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.rawDeserializeFn">
            <summary>
            Define custom raw deserialization fn for objects
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.ExcludePropertyNames">
            <summary>
            Exclude specific properties of this type from being serialized
            </summary>
        </member>
        <member name="F:ServiceStack.Text.PropertyConvention.Strict">
            <summary>
            The property names on target types must match property names in the JSON source
            </summary>
        </member>
        <member name="F:ServiceStack.Text.PropertyConvention.Lenient">
            <summary>
            The property names on target types may not match the property names in the JSON source
            </summary>
        </member>
        <member name="F:ServiceStack.Text.TimeSpanHandler.DurationFormat">
            <summary>
            Uses the xsd format like PT15H10M20S
            </summary>
        </member>
        <member name="F:ServiceStack.Text.TimeSpanHandler.StandardFormat">
            <summary>
            Uses the standard .net ToString method of the TimeSpan class
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonExtensions.Get``1(System.Collections.Generic.Dictionary{System.String,System.String},System.String,``0)">
            <summary>
            Get JSON string value converted to T
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonExtensions.Get(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Get JSON string value
            </summary>
        </member>
        <member name="P:ServiceStack.Text.JsonObject.Item(System.String)">
            <summary>
            Get JSON string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonObject.GetUnescaped(System.String)">
            <summary>
            Get unescaped string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonObject.Child(System.String)">
            <summary>
            Get unescaped string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonObject.WriteValue(System.IO.TextWriter,System.Object)">
            <summary>
            Write JSON Array, Object, bool or number values as raw string
            </summary>
        </member>
        <member name="T:ServiceStack.Text.JsonSerializer">
            <summary>
            Creates an instance of a Type from a string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonSerializer`1.DeserializeFromString(System.String)">
            <summary>
            Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Json.JsonTypeSerializer.WriteRawString(System.IO.TextWriter,System.String)">
            <summary>
            Shortcut escape when we're sure value doesn't contain any escaped chars
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:ServiceStack.Text.Json.JsonTypeSerializer.ConvertFromUtf32(System.Int32)">
            <summary>
            Given a character as utf32, returns the equivalent string provided that the character
            is legal json.
            </summary>
            <param name="utf32"></param>
            <returns></returns>
        </member>
        <member name="F:ServiceStack.Text.Json.JsonUtils.EscapedBackslash">
            <summary>
            Micro-optimization keep pre-built char arrays saving a .ToCharArray() + function call (see .net implementation of .Write(string))
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Json.JsonUtils.HasAnyEscapeChars(System.String,System.Boolean)">
            <summary>
            Searches the string for one or more non-printable characters.
            </summary>
            <param name="value">The string to search.</param>
            <param name="escapeHtmlChars"></param>
            <returns>True if there are any characters that require escaping. False if the value can be written verbatim.</returns>
            <remarks>
            Micro optimizations: since quote and backslash are the only printable characters requiring escaping, removed previous optimization
            (using flags instead of value.IndexOfAny(EscapeChars)) in favor of two equality operations saving both memory and CPU time.
            Also slightly reduced code size by re-arranging conditions.
            TODO: Possible Linq-only solution requires profiling: return value.Any(c => !c.IsPrintable() || c == QuoteChar || c == EscapeChar);
            </remarks>
        </member>
        <member name="T:ServiceStack.Text.Json.JsonWriter`1">
            <summary>
            Implement the serializer using a more static approach
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.Text.Jsv.JsvWriter`1">
            <summary>
            Implement the serializer using a more static approach
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.Text.Marc.Link`2">
            <summary>
            Pretty Thread-Safe cache class from:
            http://code.google.com/p/dapper-dot-net/source/browse/Dapper/SqlMapper.cs
            
            This is a micro-cache; suitable when the number of terms is controllable (a few hundred, for example),
            and strictly append-only; you cannot change existing values. All key matches are on **REFERENCE**
            equality. The type is fully thread-safe.
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Pools.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Pools.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.Pools.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.Pools.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.Pools.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Pools.PooledObject`1">
            <summary>
            this is RAII object to automatically release pooled object when its owning pool
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Pools.SharedPools">
            <summary>
            Shared object pool for roslyn
            
            Use this shared pool if only concern is reducing object allocations.
            if perf of an object pool itself is also a concern, use ObjectPool directly.
            
            For example, if you want to create a million of small objects within a second, 
            use the ObjectPool directly. it should have much less overhead than using this.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Pools.SharedPools.BigDefault``1">
            <summary>
            pool that uses default constructor with 100 elements pooled
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Pools.SharedPools.Default``1">
            <summary>
            pool that uses default constructor with 20 elements pooled
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Pools.SharedPools.StringIgnoreCaseDictionary``1">
            <summary>
            pool that uses string as key with StringComparer.OrdinalIgnoreCase as key comparer
            </summary>
        </member>
        <member name="F:ServiceStack.Text.Pools.SharedPools.StringIgnoreCaseHashSet">
            <summary>
            pool that uses string as element with StringComparer.OrdinalIgnoreCase as element comparer
            </summary>
        </member>
        <member name="F:ServiceStack.Text.Pools.SharedPools.StringHashSet">
            <summary>
            pool that uses string as element with StringComparer.Ordinal as element comparer
            </summary>
        </member>
        <member name="F:ServiceStack.Text.Pools.SharedPools.ByteArray">
            <summary>
            Used to reduce the # of temporary byte[]s created to satisfy serialization and
            other I/O requests
            </summary>
        </member>
        <member name="F:ServiceStack.Text.Pools.SharedPools.ByteBufferSize">
            pooled memory : 4K * 512 = 4MB
        </member>
        <member name="T:ServiceStack.Text.RuntimeSerializableAttribute">
            <summary>
            Allow Type to be deserialized into late-bould object Types using __type info
            </summary>
        </member>
        <member name="T:ServiceStack.Text.IRuntimeSerializable">
            <summary>
            Allow Type to be deserialized into late-bould object Types using __type info
            </summary>
        </member>
        <member name="T:ServiceStack.Text.StringBuilderCache">
            <summary>
            Reusable StringBuilder ThreadStatic Cache
            </summary>
        </member>
        <member name="T:ServiceStack.Text.StringBuilderCacheAlt">
            <summary>
            Alternative Reusable StringBuilder ThreadStatic Cache
            </summary>
        </member>
        <member name="T:ServiceStack.Text.StringWriterCache">
            <summary>
            Reusable StringWriter ThreadStatic Cache
            </summary>
        </member>
        <member name="T:ServiceStack.Text.StringWriterCacheAlt">
            <summary>
            Alternative Reusable StringWriter ThreadStatic Cache
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Support.DoubleConverter">
            <summary>
            A class to allow the conversion of doubles to string representations of
            their exact decimal values. The implementation aims for readability over
            efficiency.
            
            Courtesy of @JonSkeet
            http://www.yoda.arachsys.com/csharp/DoubleConverter.cs
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ServiceStack.Text.Support.DoubleConverter.ToExactString(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "T:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal" -->
        <!-- Badly formed XML comment ignored for member "F:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.digits" -->
        <member name="F:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.decimalPoint">
            <summary> 
            How many digits are *after* the decimal point
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.#ctor(System.Int64)">
            <summary> 
            Constructs an arbitrary decimal expansion from the given long.
            The long must not be negative.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.MultiplyBy(System.Int32)">
            <summary>
            Multiplies the current expansion by the given amount, which should
            only be 2 or 5.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.Shift(System.Int32)">
            <summary>
            Shifts the decimal point; a negative value makes
            the decimal expansion bigger (as fewer digits come after the
            decimal place) and a positive value makes the decimal
            expansion smaller.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.Normalize">
            <summary>
            Removes leading/trailing zeroes from the expansion.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.ToString">
            <summary>
            Converts the value to a proper decimal string representation.
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Support.StringSegment">
            <summary>
            An optimized representation of a substring.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.#ctor(System.String)">
            <summary>
            Initializes an instance of the <see cref="T:ServiceStack.Text.Support.StringSegment"/> struct.
            </summary>
            <param name="buffer">
            The original <see cref="T:System.String"/>. The <see cref="T:ServiceStack.Text.Support.StringSegment"/> includes the whole <see cref="T:System.String"/>.
            </param>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Initializes an instance of the <see cref="T:ServiceStack.Text.Support.StringSegment"/> struct.
            </summary>
            <param name="buffer">The original <see cref="T:System.String"/> used as buffer.</param>
            <param name="offset">The offset of the segment within the <paramref name="buffer"/>.</param>
            <param name="length">The length of the segment.</param>
        </member>
        <member name="P:ServiceStack.Text.Support.StringSegment.Buffer">
            <summary>
            Gets the <see cref="T:System.String"/> buffer for this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.Support.StringSegment.Offset">
            <summary>
            Gets the offset within the buffer for this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.Support.StringSegment.Length">
            <summary>
            Gets the length of this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.Support.StringSegment.Value">
            <summary>
            Gets the value of this segment as a <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.Support.StringSegment.HasValue">
            <summary>
            Gets whether or not this <see cref="T:ServiceStack.Text.Support.StringSegment"/> contains a valid value.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.Equals(ServiceStack.Text.Support.StringSegment)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns><code>true</code> if the current object is equal to the other parameter; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.Equals(ServiceStack.Text.Support.StringSegment,System.StringComparison)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns><code>true</code> if the current object is equal to the other parameter; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.Equals(System.String)">
            <summary>
            Checks if the specified <see cref="T:System.String"/> is equal to the current <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            </summary>
            <param name="text">The <see cref="T:System.String"/> to compare with the current <see cref="T:ServiceStack.Text.Support.StringSegment"/>.</param>
            <returns><code>true</code> if the specified <see cref="T:System.String"/> is equal to the current <see cref="T:ServiceStack.Text.Support.StringSegment"/>; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.Equals(System.String,System.StringComparison)">
            <summary>
            Checks if the specified <see cref="T:System.String"/> is equal to the current <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            </summary>
            <param name="text">The <see cref="T:System.String"/> to compare with the current <see cref="T:ServiceStack.Text.Support.StringSegment"/>.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns><code>true</code> if the specified <see cref="T:System.String"/> is equal to the current <see cref="T:ServiceStack.Text.Support.StringSegment"/>; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.GetHashCode">
            <inheritdoc />
            <remarks>
            This GetHashCode is expensive since it allocates on every call.
            However this is required to ensure we retain any behavior (such as hash code randomization) that
            string.GetHashCode has.
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.op_Equality(ServiceStack.Text.Support.StringSegment,ServiceStack.Text.Support.StringSegment)">
            <summary>
            Checks if two specified <see cref="T:ServiceStack.Text.Support.StringSegment"/> have the same value.
            </summary>
            <param name="left">The first <see cref="T:ServiceStack.Text.Support.StringSegment"/> to compare, or <code>null</code>.</param>
            <param name="right">The second <see cref="T:ServiceStack.Text.Support.StringSegment"/> to compare, or <code>null</code>.</param>
            <returns><code>true</code> if the value of <paramref name="left"/> is the same as the value of <paramref name="right"/>; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.op_Inequality(ServiceStack.Text.Support.StringSegment,ServiceStack.Text.Support.StringSegment)">
            <summary>
            Checks if two specified <see cref="T:ServiceStack.Text.Support.StringSegment"/> have different values.
            </summary>
            <param name="left">The first <see cref="T:ServiceStack.Text.Support.StringSegment"/> to compare, or <code>null</code>.</param>
            <param name="right">The second <see cref="T:ServiceStack.Text.Support.StringSegment"/> to compare, or <code>null</code>.</param>
            <returns><code>true</code> if the value of <paramref name="left"/> is different from the value of <paramref name="right"/>; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.StartsWith(System.String,System.StringComparison)">
            <summary>
            Checks if the beginning of this <see cref="T:ServiceStack.Text.Support.StringSegment"/> matches the specified <see cref="T:System.String"/> when compared using the specified <paramref name="comparisonType"/>.
            </summary>
            <param name="text">The <see cref="T:System.String"/>to compare.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns><code>true</code> if <paramref name="text"/> matches the beginning of this <see cref="T:ServiceStack.Text.Support.StringSegment"/>; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.EndsWith(System.String,System.StringComparison)">
            <summary>
            Checks if the end of this <see cref="T:ServiceStack.Text.Support.StringSegment"/> matches the specified <see cref="T:System.String"/> when compared using the specified <paramref name="comparisonType"/>.
            </summary>
            <param name="text">The <see cref="T:System.String"/>to compare.</param>
            <param name="comparisonType">One of the enumeration values that specifies the rules to use in the comparison.</param>
            <returns><code>true</code> if <paramref name="text"/> matches the end of this <see cref="T:ServiceStack.Text.Support.StringSegment"/>; otherwise, <code>false</code>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.Substring(System.Int32,System.Int32)">
            <summary>
            Retrieves a substring from this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            The substring starts at the position specified by <paramref name="offset"/> and has the specified <paramref name="length"/>.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.</param>
            <param name="length">The number of characters in the substring.</param>
            <returns>A <see cref="T:System.String"/> that is equivalent to the substring of length <paramref name="length"/> that begins at <paramref name="offset"/> in this <see cref="T:ServiceStack.Text.Support.StringSegment"/></returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.Subsegment(System.Int32,System.Int32)">
            <summary>
            Retrieves a <see cref="T:ServiceStack.Text.Support.StringSegment"/> that represents a substring from this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            The <see cref="T:ServiceStack.Text.Support.StringSegment"/> starts at the position specified by <paramref name="offset"/> and has the specified <paramref name="length"/>.
            </summary>
            <param name="offset">The zero-based starting character position of a substring in this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.</param>
            <param name="length">The number of characters in the substring.</param>
            <returns>A <see cref="T:ServiceStack.Text.Support.StringSegment"/> that is equivalent to the substring of length <paramref name="length"/> that begins at <paramref name="offset"/> in this <see cref="T:ServiceStack.Text.Support.StringSegment"/></returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.IndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence of the character <paramref name="c"/> in this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            The search starts at <paramref name="start"/> and examines a specified number of <paramref name="count"/> character positions.
            </summary>
            <param name="c">The Unicode character to seek.</param>
            <param name="start">The zero-based index position at which the search starts. </param>
            <param name="count">The number of characters to examine.</param>
            <returns>The zero-based index position of <paramref name="c"/> from the beginning of the <see cref="T:ServiceStack.Text.Support.StringSegment"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.IndexOf(System.Char,System.Int32)">
            <summary>
            Gets the zero-based index of the first occurrence of the character <paramref name="c"/> in this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            The search starts at <paramref name="start"/>.
            </summary>
            <param name="c">The Unicode character to seek.</param>
            <param name="start">The zero-based index position at which the search starts. </param>
            <returns>The zero-based index position of <paramref name="c"/> from the beginning of the <see cref="T:ServiceStack.Text.Support.StringSegment"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.IndexOf(System.Char)">
            <summary>
            Gets the zero-based index of the first occurrence of the character <paramref name="c"/> in this <see cref="T:ServiceStack.Text.Support.StringSegment"/>.
            </summary>
            <param name="c">The Unicode character to seek.</param>
            <returns>The zero-based index position of <paramref name="c"/> from the beginning of the <see cref="T:ServiceStack.Text.Support.StringSegment"/> if that character is found, or -1 if it is not.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.Trim">
            <summary>
            Removes all leading and trailing whitespaces.
            </summary>
            <returns>The trimmed <see cref="T:ServiceStack.Text.Support.StringSegment"/>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.TrimStart">
            <summary>
            Removes all leading whitespaces.
            </summary>
            <returns>The trimmed <see cref="T:ServiceStack.Text.Support.StringSegment"/>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.TrimEnd">
            <summary>
            Removes all trailing whitespaces.
            </summary>
            <returns>The trimmed <see cref="T:ServiceStack.Text.Support.StringSegment"/>.</returns>
        </member>
        <member name="M:ServiceStack.Text.Support.StringSegment.ToString">
            <summary>
            Returns the <see cref="T:System.String"/> represented by this <see cref="T:ServiceStack.Text.Support.StringSegment"/> or <code>String.Empty</code> if the <see cref="T:ServiceStack.Text.Support.StringSegment"/> does not contain a value.
            </summary>
            <returns>The <see cref="T:System.String"/> represented by this <see cref="T:ServiceStack.Text.Support.StringSegment"/> or <code>String.Empty</code> if the <see cref="T:ServiceStack.Text.Support.StringSegment"/> does not contain a value.</returns>
        </member>
        <member name="T:ServiceStack.Text.TypeSerializer">
            <summary>
            Creates an instance of a Type from a string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.CanCreateFromString(System.Type)">
            <summary>
            Determines whether the specified type is convertible from string.
            </summary>
            <param name="type">The type.</param>
            <returns>
            	<c>true</c> if the specified type is convertible from string; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.DeserializeFromString``1(System.String)">
            <summary>
            Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.DeserializeFromString(System.String,System.Type)">
            <summary>
            Parses the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.ToStringDictionary``1(``0)">
            <summary>
            Useful extension method to get the Dictionary[string,string] representation of any POCO type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.Dump``1(``0)">
            <summary>
            Recursively prints the contents of any POCO object in a human-friendly, readable format
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.PrintDump``1(``0)">
            <summary>
            Print Dump to Console.WriteLine
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.Print(System.String,System.Object[])">
            <summary>
            Print string.Format to Console.WriteLine
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer`1.DeserializeFromString(System.String)">
            <summary>
            Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.AutoMappingUtils.PopulateWith(System.Object)">
            <summary>
            Populate an object with Example data.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.AutoMappingUtils.PopulateObjectInternal(System.Object,System.Collections.Generic.Dictionary{System.Type,System.Int32})">
            <summary>
            Populates the object with example data.
            </summary>
            <param name="obj"></param>
            <param name="recursionInfo">Tracks how deeply nested we are</param>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.Licensing">
            <summary>
            Public Code API to register commercial license for ServiceStack.
            </summary>
        </member>
        <member name="T:ServiceStack.LicenseUtils">
            <summary>
            Internal Utilities to verify licensing
            </summary>
        </member>
        <member name="M:ServiceStack.PathUtils.MapProjectPath(System.String)">
            <summary>
            Maps the path of a file in the context of a VS project in a Console App
            </summary>
            <param name="relativePath">the relative path</param>
            <returns>the absolute path</returns>
            <remarks>Assumes static content is two directories above the /bin/ directory,
            eg. in a unit test scenario  the assembly would be in /bin/Debug/.</remarks>
        </member>
        <member name="M:ServiceStack.PathUtils.MapProjectPlatformPath(System.String)">
            <summary>
            Maps the path of a file in the context of a VS 2017+ multi-platform project in a Console App
            </summary>
            <param name="relativePath">the relative path</param>
            <returns>the absolute path</returns>
            <remarks>Assumes static content is two directories above the /bin/ directory,
            eg. in a unit test scenario  the assembly would be in /bin/Debug/net45</remarks>
        </member>
        <member name="M:ServiceStack.PathUtils.MapAbsolutePath(System.String)">
            <summary>
            Maps the path of a file in the bin\ folder of a self-hosted scenario
            </summary>
            <param name="relativePath">the relative path</param>
            <returns>the absolute path</returns>
            <remarks>Assumes static content is copied to /bin/ folder with the assemblies</remarks>
        </member>
        <member name="M:ServiceStack.PathUtils.MapHostAbsolutePath(System.String)">
            <summary>
            Maps the path of a file in an ASP.NET hosted scenario
            </summary>
            <param name="relativePath">the relative path</param>
            <returns>the absolute path</returns>
            <remarks>Assumes static content is in the parent folder of the /bin/ directory</remarks>
        </member>
        <member name="M:ServiceStack.PlatformExtensions.AddAttributes(System.Reflection.PropertyInfo,System.Attribute[])">
            <summary>
            Add a Property attribute at runtime. 
            <para>Not threadsafe, should only add attributes on Startup.</para>
            </summary>
        </member>
        <member name="M:ServiceStack.PlatformExtensions.ReplaceAttribute(System.Reflection.PropertyInfo,System.Attribute)">
            <summary>
            Add a Property attribute at runtime. 
            <para>Not threadsafe, should only add attributes on Startup.</para>
            </summary>
        </member>
        <member name="T:ServiceStack.QueryStringWriter`1">
            <summary>
            Implement the serializer using a more static approach
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ServiceStack.ReflectionExtensions.New``1(System.Type)">
            <summary>
            Creates a new instance of type. 
            First looks at JsConfig.ModelFactory before falling back to CreateInstance
            </summary>
        </member>
        <member name="M:ServiceStack.ReflectionExtensions.New(System.Type)">
            <summary>
            Creates a new instance of type. 
            First looks at JsConfig.ModelFactory before falling back to CreateInstance
            </summary>
        </member>
        <member name="M:ServiceStack.ReflectionExtensions.CreateInstance(System.Type)">
            <summary>
            Creates a new instance from the default constructor of type
            </summary>
        </member>
        <member name="T:ServiceStack.BigInteger">
            <summary>
            BigInteger library by Chew Keong TAN (See project source for info).
            </summary>
        </member>
        <member name="T:ServiceStack.IPaddingProvider">
            <summary>
            Interface which must be implemented by all custom padding providers. 
            Padding is used to provide randomness and unpredictability to the data 
            before it is encrypted.
            </summary>
        </member>
        <member name="M:ServiceStack.IPaddingProvider.EncodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Adds padding to the input data and returns the padded data.
            </summary>
            <param name="dataBytes">Data to be padded prior to encryption</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Padded message</returns>
        </member>
        <member name="M:ServiceStack.IPaddingProvider.DecodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Removes padding that was added to the unencrypted data prior to encryption.
            </summary>
            <param name="dataBytes">Data to have padding removed</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Unpadded message</returns>
        </member>
        <member name="M:ServiceStack.IPaddingProvider.GetMaxMessageLength(ServiceStack.RSAParameters)">
            <summary>
            Gets the maximum message length for this padding provider.
            </summary>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Max message length</returns>
        </member>
        <member name="T:ServiceStack.PKCS1v1_5">
            <summary>
            Uses PKCS#1 v 1.5 padding scheme to pad the data.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:ServiceStack.PKCS1v1_5.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ServiceStack.PKCS1v1_5.EncodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Adds padding to the input data and returns the padded data.
            </summary>
            <param name="dataBytes">Data to be padded prior to encryption</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Padded message</returns>
        </member>
        <member name="M:ServiceStack.PKCS1v1_5.DecodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Removes padding that was added to the unencrypted data prior to encryption.
            </summary>
            <param name="dataBytes">Data to have padding removed</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Unpadded message</returns>
        </member>
        <member name="M:ServiceStack.PKCS1v1_5.GetMaxMessageLength(ServiceStack.RSAParameters)">
            <summary>
            Gets the maximum message length for this padding provider.
            </summary>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Max message length</returns>
        </member>
        <member name="T:ServiceStack.NoPadding">
            <summary>
            The NoPadding class does not add any padding to the data.  
            This is not recommended.
            </summary>
        </member>
        <member name="M:ServiceStack.NoPadding.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ServiceStack.NoPadding.ServiceStack#IPaddingProvider#EncodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Adds padding to the input data and returns the padded data.
            </summary>
            <param name="dataBytes">Data to be padded prior to encryption</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Padded message</returns>
        </member>
        <member name="M:ServiceStack.NoPadding.ServiceStack#IPaddingProvider#DecodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Removes padding that was added to the unencrypted data prior to encryption.
            </summary>
            <param name="dataBytes">Data to have padding removed</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Unpadded message</returns>
        </member>
        <member name="M:ServiceStack.NoPadding.GetMaxMessageLength(ServiceStack.RSAParameters)">
            <summary>
            Gets the maximum message length for this padding provider.
            </summary>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Max message length</returns>
        </member>
        <member name="T:ServiceStack.OAEP">
            <summary>
            Uses OAEP Padding defined in PKCS#1 v 2.1.  Uses the 
            default standard SHA1 hash.  This padding provider is 
            compatible with .NET's OAEP implementation.
            </summary>
        </member>
        <member name="M:ServiceStack.OAEP.#ctor">
            <summary>
            Default constructor.  Uses the default SHA1 Hash for OAEP hash calculation.
            </summary>
        </member>
        <member name="M:ServiceStack.OAEP.#ctor(ServiceStack.IHashProvider,System.Int32)">
            <summary>
            Internal constructor (used to perform OAEP with a different hash and hash output length
            </summary>
            <param name="ohashProvider"></param>
            <param name="hashLength"></param>
        </member>
        <member name="M:ServiceStack.OAEP.EncodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Adds padding to the input data and returns the padded data.
            </summary>
            <param name="dataBytes">Data to be padded prior to encryption</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Padded message</returns>
        </member>
        <member name="M:ServiceStack.OAEP.DecodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Removes padding that was added to the unencrypted data prior to encryption.
            </summary>
            <param name="dataBytes">Data to have padding removed</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Unpadded message</returns>
        </member>
        <member name="M:ServiceStack.OAEP.GetMaxMessageLength(ServiceStack.RSAParameters)">
            <summary>
            Gets the maximum message length for this padding provider.
            </summary>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Max message length</returns>
        </member>
        <member name="T:ServiceStack.OAEP256">
            <summary>
            Uses OAEP Padding Scheme defined in PKCS#1 v 2.1.  Uses a 
            SHA256 hash.  This padding provider is currently 
            not compatible with .NET's OAEP implementation.
            </summary>
        </member>
        <member name="M:ServiceStack.OAEP256.#ctor">
            <summary>
            Default constructor.  Uses a SHA256 Hash for OAEP hash calculation.
            This PaddingProvider provides added security to message padding, 
            however it requires the data to be encrypted to be shorter and 
            is not compatible with the RSACryptoServiceProvider's implementation 
            of OAEP.
            </summary>
        </member>
        <member name="M:ServiceStack.OAEP256.EncodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Adds padding to the input data and returns the padded data.
            </summary>
            <param name="dataBytes">Data to be padded prior to encryption</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Padded message</returns>
        </member>
        <member name="M:ServiceStack.OAEP256.DecodeMessage(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Removes padding that was added to the unencrypted data prior to encryption.
            </summary>
            <param name="dataBytes">Data to have padding removed</param>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Unpadded message</returns>
        </member>
        <member name="M:ServiceStack.OAEP256.GetMaxMessageLength(ServiceStack.RSAParameters)">
            <summary>
            Gets the maximum message length for this padding provider.
            </summary>
            <param name="params">RSA Parameters used for padding computation</param>
            <returns>Max message length</returns>
        </member>
        <member name="T:ServiceStack.ISignatureProvider">
            <summary>
            All custom signature providers must implement this interface.  The 
            RSACrypto class handles encryption and decryption of data.  The 
            SignatureProvider is intended to provide the hashing and signature
            generation mechanism used to create the comparison data.
            </summary>
        </member>
        <member name="M:ServiceStack.ISignatureProvider.EncodeSignature(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Generates a hash for the input data.
            </summary>
            <param name="dataBytes">Data to be signed</param>
            <param name="params">RSA Parameters used for signature calculation</param>
            <returns>Computed signature (pre-encryption)</returns>
        </member>
        <member name="M:ServiceStack.ISignatureProvider.VerifySignature(System.Byte[],System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Verifies the signed data against the unsigned data after decryption.
            </summary>
            <param name="dataBytes">Unsigned data</param>
            <param name="signedDataBytes">Signed data (after decryption)</param>
            <param name="params">RSAParameters used for signature computation</param>
            <returns>Boolean representing whether the input data matches the signed data</returns>
        </member>
        <member name="T:ServiceStack.EMSAPKCS1v1_5_SHA1">
            <summary>
            Uses the DER (Distinguished Encoding Rules) 
            and the SHA1 hash provider for encoding generation.
            </summary>
        </member>
        <member name="M:ServiceStack.EMSAPKCS1v1_5_SHA1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ServiceStack.EMSAPKCS1v1_5_SHA1.EncodeSignature(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Hashes and encodes the signature for encryption.  Uses the DER (Distinguished Encoding Rules) 
            and the SHA1 hash provider for encoding generation.
            </summary>
            <param name="dataBytes">Data to be signed</param>
            <param name="params">RSA Parameters used for signature calculation</param>
            <returns>Computed signature (pre-encryption)</returns>
        </member>
        <member name="M:ServiceStack.EMSAPKCS1v1_5_SHA1.ServiceStack#ISignatureProvider#VerifySignature(System.Byte[],System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Verifies the signed data against the unsigned data after decryption.
            </summary>
            <param name="dataBytes">Unsigned data</param>
            <param name="signedDataBytes">Signed data (after decryption)</param>
            <param name="params">RSAParameters used for signature computation</param>
            <returns>Boolean representing whether the input data matches the signed data</returns>
        </member>
        <member name="T:ServiceStack.EMSAPKCS1v1_5_SHA256">
            <summary>
            Uses the DER (Distinguished Encoding Rules) 
            and the SHA256 hash provider for encoding generation.
            </summary>
        </member>
        <member name="M:ServiceStack.EMSAPKCS1v1_5_SHA256.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ServiceStack.EMSAPKCS1v1_5_SHA256.EncodeSignature(System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Hashes and encodes the signature for encryption.  Uses the DER (Distinguished Encoding Rules) 
            and the SHA256 hash provider for encoding generation.
            </summary>
            <param name="dataBytes">Data to be signed</param>
            <param name="params">RSA Parameters used for signature calculation</param>
            <returns>Computed signature (pre-encryption)</returns>
        </member>
        <member name="M:ServiceStack.EMSAPKCS1v1_5_SHA256.ServiceStack#ISignatureProvider#VerifySignature(System.Byte[],System.Byte[],ServiceStack.RSAParameters)">
            <summary>
            Verifies the signed data against the unsigned data after decryption.
            </summary>
            <param name="dataBytes">Unsigned data</param>
            <param name="signedDataBytes">Signed data (after decryption)</param>
            <param name="params">RSAParameters used for signature computation</param>
            <returns>Boolean representing whether the input data matches the signed data</returns>
        </member>
        <member name="T:ServiceStack.IHashProvider">
            <summary>
            Base interface that must be implemented by all hash providers.
            </summary>
        </member>
        <member name="M:ServiceStack.IHashProvider.ComputeHash(System.Byte[])">
            <summary>
            Compute the hash of the input byte array and return the hashed value as a byte array.
            </summary>
            <param name="inputData">Input data</param>
            <returns>Hashed data.</returns>
        </member>
        <member name="T:ServiceStack.SHA256">
            <summary>
            Hash provider based on SHA256
            </summary>
        </member>
        <member name="M:ServiceStack.SHA256.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ServiceStack.SHA256.ServiceStack#IHashProvider#ComputeHash(System.Byte[])">
            <summary>
            Compute the hash of the input byte array and return the hashed value as a byte array.
            </summary>
            <param name="inputData">Input data</param>
            <returns>SHA256 Hashed data</returns>
        </member>
        <member name="T:ServiceStack.HMACSHA256">
            <summary>
            Hash provider based on HMACSHA256 to allow inclusion of a hash seed value
            </summary>
        </member>
        <member name="M:ServiceStack.HMACSHA256.#ctor(System.Byte[])">
            <summary>
            Constructor accepting a private key (seed) value
            </summary>
            <param name="privateKey">Byte array containing the private hash seed</param>
        </member>
        <member name="M:ServiceStack.HMACSHA256.ServiceStack#IHashProvider#ComputeHash(System.Byte[])">
            <summary>
            Compute the hash of the input byte array and return the hashed value as a byte array.
            </summary>
            <param name="inputData">Input data</param>
            <returns>HMACSHA256 Hashed data.</returns>
        </member>
        <member name="T:ServiceStack.SHA1">
            <summary>
            Hash provider based on SHA1
            </summary>
        </member>
        <member name="M:ServiceStack.SHA1.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ServiceStack.SHA1.ServiceStack#IHashProvider#ComputeHash(System.Byte[])">
            <summary>
            Compute the hash of the input byte array and return the hashed value as a byte array.
            </summary>
            <param name="inputData">Input data</param>
            <returns>SHA1 Hashed data.</returns>
        </member>
        <member name="T:ServiceStack.HMACSHA1">
            <summary>
            Hash provider based on HMACSHA1 to allow inclusion of a hash seed value
            </summary>
        </member>
        <member name="M:ServiceStack.HMACSHA1.#ctor(System.Byte[])">
            <summary>
            Constructor accepting a private key (seed) value
            </summary>
            <param name="privateKey">Byte array containing the private hash seed</param>
        </member>
        <member name="M:ServiceStack.HMACSHA1.ServiceStack#IHashProvider#ComputeHash(System.Byte[])">
            <summary>
            Compute the hash of the input byte array and return the hashed value as a byte array.
            </summary>
            <param name="inputData">Input data</param>
            <returns>HMACSHA1 Hashed data.</returns>
        </member>
        <member name="T:ServiceStack.RSACryptoServiceProvider">
            <summary>
            RSA Cryptography class
            </summary>
        </member>
        <member name="P:ServiceStack.RSACryptoServiceProvider.PaddingProvider">
            <summary>
            Different versions of RSA use different padding schemes.  This property allows you to 
            set the padding scheme you wish to use.  If not set, the default of OAEP will be 
            used.  While PKCS1 v1.5 is supported, OAEP is the recommended padding scheme to use.
            You can create your own padding schemes by implementing the IPaddingProvider interface.
            </summary>
            <value>Padding provider instance</value>
            <returns>Current padding provider</returns>
        </member>
        <member name="P:ServiceStack.RSACryptoServiceProvider.MaxMessageLength">
            <summary>
            Based on the padding provider, messages are stricted to certain lengths for encryption.  Also,
            ensure that the key pair has either been generated or imported.
            </summary>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.#ctor">
            <summary>
            Default constructor for the RSA Class.  A cipher strength of 1024-bit will used by default.  To specify 
            a higher cipher strength, please use the alternate RSACrypto(cipherStrength) constructor.
            </summary>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.#ctor(System.Int32)">
            <summary>
            RSA Class Constructor
            </summary>
            <param name="cipherStrength">
            Cipher strength in bits.  2048 is recommended.  Must be a multiple of 8.  
            Max supported by this class is 4096.  Minimum is 256.  Cipher strength only 
            needs to be specified if generating new key pairs.  It is not necessary to 
            know the cipher strength when importing existing key pairs.
            </param>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.ToXmlString(System.Boolean)">
            <summary>
            Return the currently loaded key as XML.  This method will automatically 
            return an empty string if no key has been loaded.
            </summary>
            <param name="includePrivate">Signals whether to include the private key in the output data.</param>
            <returns>XML String with the key data.</returns>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.FromXmlString(System.String)">
            <summary>
            Sets the current class internal variables based on the supplied XML. 
            Attempts to validate the XML prior to setting.
            </summary>
            <param name="xmlString">XML String containing key info</param>
            <remarks></remarks>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.ImportParameters(ServiceStack.RSAParameters)">
            <summary>
            Import an existing set of RSA Parameters.  If only the public key is to be loaded, 
            Do not set the P, Q, DP, DQ, IQ or D values.  If P, Q or D are set, the parameters 
            will automatically be validated for existence of private key.
            </summary>
            <param name="params">RSAParameters object containing key data.</param>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.ExportParameters(System.Boolean)">
            <summary>
            Returns an RSAParameters object that contains the key data for the currently loaded key.  
            </summary>
            <returns>Instance of the currently loaded RSAParameters object or null if no key is loaded</returns>
            <remarks></remarks>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.ImportCspBlob(System.Byte[])">
            <summary>
            Imports a blob that represents asymmetric key information.
            </summary>
            <param name="rawData">A byte array that represents an asymmetric key blob.</param>
            <exception cref="T:ServiceStack.CryptographicException">Invalid key blob data</exception>
            <returns>Initialized RSAParameters structure</returns>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.ExportCspBlob(System.Boolean)">
            <summary>
            Exports a blob that contains the key information associated with an AsymmetricAlgorithm object.
            </summary>
            <param name="includePrivateParameters">true to include the private key; otherwise, false.</param>
            <returns>A byte array that contains the key information associated with an AsymmetricAlgorithm object</returns>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.GenerateKeys">
            <summary>
            Generate the RSA Key Pair using the default exponent of 65537.
            </summary>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.GenerateKeys(System.Int32)">
            <summary>
            Generate the RSA Key Pair using a supplied cipher strength and the default 
            exponent value of 65537.  If a cipherStrength was specified in the constructor, 
            the supplied value will override it.
            </summary>
            <param name="cipherStrength">The strength of the cipher in bits.  Must be a multiple of 8 
            and between 256 and 4096</param>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.GenerateKeys(System.Int32,System.Int32)">
            <summary>
            Generate the RSA Key Pair using a supplied cipher strength value and exponent value.  
            A prime number value between 3 and 65537 is recommended for the exponent.  Larger 
            exponents can increase security but also increase encryption time.  Your supplied 
            exponent may be automatically adjusted to ensure compatibility with the RSA algorithm 
            security requirements.  If a cipherStrength was specified in the constructor, 
            the supplied <paramref name="cipherStrength"/> value will override it.
            </summary>
            <param name="cipherStrength">The strength of the cipher in bits.  Must be a multiple of 8 
            and between 256 and 4096</param>
            <param name="exponent">Custom exponent value to be used for RSA Calculation</param>
        </member>
        <member name="T:ServiceStack.RSACryptoServiceProvider.KeysGenerated">
            <summary>
            Delegate for OnKeysGenerated event 
            </summary>
            <param name="sender">Object</param>
        </member>
        <member name="E:ServiceStack.RSACryptoServiceProvider.OnKeysGenerated">
            <summary>
            Fires when key generation is complete.
            </summary>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.Encrypt(System.Byte[])">
            <summary>
            Encrypt input bytes with the public key.  Data can only be decrypted with 
            the private key.  If no PaddingProvider is set, the default padding provider of OAEP will be assumed.  To 
            specify a different padding algorithm, make sure you set the PaddingProvider property.
            </summary>
            <param name="dataBytes">Data bytes to be encrypted</param>
            <returns>Encrypted byte array</returns>
            <remarks>Key generation is CPU intensive.  It is highly recommended that you create 
            your key pair in advance and use a predetermined key pair.  If you do choose to allow 
            the key pair to be automatically generated, it can be exported to XML or an RSAParameter 
            set after the encryption is complete.</remarks>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.EncryptPrivate(System.Byte[])">
            <summary>
            Run the encryption routine using the private key for encryption.  While this may be useful in some 
            fringe scenarios, if simple verification is needed it is recommended that you use the Sign() method 
            instead, which signs a hashed version of your data.   If no PaddingProvider is set, the default padding 
            provider of OAEP will be assumed.  To specify a different padding algorithm, make sure you set the 
            PaddingProvider property.  
            </summary>
            <param name="databytes">Data to be encrypted with the private key</param>
            <returns>Encrypted data bytes</returns>
            <remarks>
            <para>This method uses the PaddingProvider for message verification.  To create signature 
            hashes, please use the SignData and VerifyData methods.</para>
            <para>Data encrypted this way can be decrypted using your PUBLIC KEY.  This method of encryption is meant 
            for verification purposes only and does not secure your data against decryption.</para>
            </remarks>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.SignData(System.Byte[],ServiceStack.ISignatureProvider)">
            <summary>
            Sign a hash of the input data using the supplied Signature Provider and encrypt with the private key.    
            </summary>
            <param name="dataBytes">Data to be hashed and signed</param>
            <param name="signatureProvider">The signature provider to use for signature generation.</param>
            <returns>Signed hash bytes</returns>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.Decrypt(System.Byte[])">
            <summary>
            Decrypt data that was encrypted using the Public Key.  If no PaddingProvider is set, the default
            padding provider of OAEP will be assumed.  To specify a different padding algorithm, make sure 
            you set the PaddingProvider property.
            </summary>
            <param name="encryptedBytes">Encrypted bytes</param>
            <returns>Decrypted bytes</returns>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.DecryptPublic(System.Byte[])">
            <summary>
            Decrypt data that was encrypted with the Private Key.  NOTE:  This method 
            uses the PaddingProvider for message decoding.  To create signature 
            hashes, please use the SignData and VerifyData methods.  If no PaddingProvider is set, the default
            padding provider of OAEP will be assumed.  To specify a different padding algorithm, make sure 
            you set the PaddingProvider property.
            </summary>
            <param name="encryptedBytes">Encrypted bytes</param>
            <returns>Decrypted bytes</returns>
        </member>
        <member name="M:ServiceStack.RSACryptoServiceProvider.VerifyData(System.Byte[],System.Byte[],ServiceStack.ISignatureProvider)">
            <summary>
            Verify the signature against the unsigned data.  The encryptedData is decrypted using the public key and 
            the unsignedData is hashed and compared to the un-encrypted signed data using the supplied SignatureProvider.  
            </summary>
            <param name="unsignedData">The raw, unencrypted data to be hashed and compared.</param>
            <param name="encryptedData">The data that has been hashed and encrypted with the private key.</param>
            <param name="signatureProvider">The signature provider that matches the algorithm used to generate the original signature</param>
            <returns>Boolean representing whether the signature was valid (verified)</returns>
        </member>
        <member name="T:ServiceStack.CryptographicException">
            <summary>
            Cryptographic Exception
            </summary>
        </member>
        <member name="M:ServiceStack.CryptographicException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:ServiceStack.CryptographicException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Error Message</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="F:ServiceStack.AlgorithmIdentifier.CALG_RSA_KEYX">
            <summary>
            CALG_RSA_KEYX = (ALG_CLASS_KEY_EXCHANGE|ALG_TYPE_RSA|ALG_SID_RSA_ANY)
            </summary>
        </member>
        <member name="F:ServiceStack.KeyBlobType.SimpleBlob">
            <summary>
            Simple Key BLOB
            </summary>
        </member>
        <member name="F:ServiceStack.KeyBlobType.PublicKeyBlob">
            <summary>
            Public Key BLOB
            </summary>
        </member>
        <member name="F:ServiceStack.KeyBlobType.PrivateKeyBlob">
            <summary>
            Private Key BLOB
            </summary>
        </member>
        <member name="F:ServiceStack.KeyBlobType.PlainTextKeyBlob">
            <summary>
            PlainText Key BLOB
            </summary>
        </member>
        <member name="F:ServiceStack.KeyBlobType.OpaqueKeyBlob">
            <summary>
            Opaque Key BLOB
            </summary>
        </member>
        <member name="F:ServiceStack.KeyBlobType.PublicKeyBlobEx">
            <summary>
            Public Key BLOB Extended
            </summary>
        </member>
        <member name="F:ServiceStack.KeyBlobType.SymmetricWrapKeyBlob">
            <summary>
            Symmetric Wrap Key BLOB
            </summary>
        </member>
        <member name="T:ServiceStack.BlobHeader">
            <summary>
            A BLOBHEADER / PUBLICKEYSTRUC structure (Import from WinCrypt.h)
            </summary>
            <note>http://msdn.microsoft.com/en-us/library/ms884652.aspx</note>
        </member>
        <member name="F:ServiceStack.BlobHeader.BlobType">
            <summary>
            Key BLOB type. The only BLOB types currently defined are PUBLICKEYBLOB, PRIVATEKEYBLOB, and SIMPLEBLOB. Other key BLOB types will be defined as needed.
            </summary>
        </member>
        <member name="F:ServiceStack.BlobHeader.Version">
            <summary>
            Version number of the key BLOB format. This member currently must always have a value of 0x02.
            </summary>
        </member>
        <member name="F:ServiceStack.BlobHeader.Reserved">
            <summary>
            Reserved for future use. This member must be set to zero.
            </summary>
        </member>
        <member name="F:ServiceStack.BlobHeader.KeyAlgorithm">
            <summary>
            Algorithm identifier for the key contained by the key BLOB structure
            </summary>
        </member>
        <member name="M:ServiceStack.BlobHeader.FromBinary(System.IO.BinaryReader)">
            <summary>
            Create and initialize structure from binary data
            </summary>
            <exception cref="T:ServiceStack.CryptographicException">On validate errors</exception>
            <returns>Initialized structure</returns>
        </member>
        <member name="M:ServiceStack.BlobHeader.ToBinary(System.IO.BinaryWriter)">
            <summary>
            Serializes structure as binary data
            </summary>
        </member>
        <member name="M:ServiceStack.BlobHeader.FromRSAParameters(ServiceStack.KeyBlobType)">
            <summary>
            Create and initialize structure from RSAParameters
            </summary>
            <returns>Initialized structure</returns>
        </member>
        <member name="M:ServiceStack.BlobHeader.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:ServiceStack.RSAPubKey">
            <summary>
            RSA public key data
            </summary>
            <note>http://msdn.microsoft.com/en-us/library/aa387685(v=VS.85).aspx</note>
        </member>
        <member name="F:ServiceStack.RSAPubKey.Magic">
            <summary>
            The magic member must be set to 0x31415352 (public only) / 0x32415352 (including private). This hex value is the ASCII encoding of RSA1 / RSA2.
            </summary>
        </member>
        <member name="F:ServiceStack.RSAPubKey.BitLength">
            <summary>
            # of bits in modulus
            </summary>
        </member>
        <member name="F:ServiceStack.RSAPubKey.PublicExponent">
            <summary>
            Public exponent
            </summary>
        </member>
        <member name="M:ServiceStack.RSAPubKey.FromBinary(System.IO.BinaryReader)">
            <summary>
            Create and initialize structure from binary data
            </summary>
            <exception cref="T:ServiceStack.CryptographicException">On validate errors</exception>
            <returns>Initialized structure</returns>
        </member>
        <member name="M:ServiceStack.RSAPubKey.ToBinary(System.IO.BinaryWriter)">
            <summary>
            Serializes structure as binary data
            </summary>
        </member>
        <member name="M:ServiceStack.RSAPubKey.FromRSAParameters(ServiceStack.RSAParameters,System.Boolean)">
            <summary>
            Create and initialize structure from RSAParameters
            </summary>
            <returns>Initialized structure</returns>
        </member>
        <member name="M:ServiceStack.RSAPubKey.ToRSAParameters">
            <summary>
            Create and initialize RSAParameters structure
            </summary>
            <returns>Initialized structure</returns>
            <note>http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsaparameters.aspx</note>
        </member>
        <member name="M:ServiceStack.RSAPubKey.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:ServiceStack.PrivateKeyBlob">
            <summary>
            Private-key BLOBs, type PRIVATEKEYBLOB, are used to store private keys outside a CSP. Extended provider private-key BLOBs have the following format.
            </summary>
        </member>
        <member name="F:ServiceStack.PrivateKeyBlob.Header">
            <summary>
            BLOB Header
            </summary>
        </member>
        <member name="F:ServiceStack.PrivateKeyBlob.RSAPubKey">
            <summary>
            RSA public key data
            </summary>
        </member>
        <member name="F:ServiceStack.PrivateKeyBlob.Modulus">
            <summary>
            The modulus. This has a value of prime1 * prime2 and is often known as n.
            </summary>
        </member>
        <member name="F:ServiceStack.PrivateKeyBlob.Prime1">
            <summary>
            Prime number 1, often known as p.
            </summary>
        </member>
        <member name="F:ServiceStack.PrivateKeyBlob.Prime2">
            <summary>
            Prime number 2, often known as q.
            </summary>
        </member>
        <member name="F:ServiceStack.PrivateKeyBlob.Exponent1">
            <summary>
            Exponent 1. This has a numeric value of d mod (p - 1).
            </summary>
        </member>
        <member name="F:ServiceStack.PrivateKeyBlob.Exponent2">
            <summary>
            Exponent 2. This has a numeric value of d mod (q - 1).
            </summary>
        </member>
        <member name="F:ServiceStack.PrivateKeyBlob.Coefficient">
            <summary>
            Coefficient. This has a numeric value of (inverse of q mod p).
            </summary>
        </member>
        <member name="F:ServiceStack.PrivateKeyBlob.PrivateExponent">
            <summary>
            Private exponent, often known as d.
            </summary>
        </member>
        <member name="M:ServiceStack.PrivateKeyBlob.FromBinary(System.IO.BinaryReader)">
            <summary>
            Create and initialize structure from binary data
            </summary>
            <exception cref="T:ServiceStack.CryptographicException">On validate errors</exception>
            <returns>Initialized structure</returns>
        </member>
        <member name="M:ServiceStack.PrivateKeyBlob.FromBinary(System.IO.BinaryReader,ServiceStack.BlobHeader)">
            <summary>
            Create and initialize structure from binary data with defined header
            </summary>
            <exception cref="T:ServiceStack.CryptographicException">On validate errors</exception>
            <returns>Initialized structure</returns>
        </member>
        <member name="M:ServiceStack.PrivateKeyBlob.ToBinary(System.IO.BinaryWriter)">
            <summary>
            Serializes structure as binary data
            </summary>
        </member>
        <member name="M:ServiceStack.PrivateKeyBlob.FromRSAParameters(ServiceStack.RSAParameters)">
            <summary>
            Create and initialize structure from RSAParameters
            </summary>
            <returns>Initialized structure</returns>
            <note>http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsaparameters.aspx</note>
        </member>
        <member name="M:ServiceStack.PrivateKeyBlob.ToRSAParameters">
            <summary>
            Create and initialize RSAParameters structure
            </summary>
            <returns>Initialized structure</returns>
            <note>http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsaparameters.aspx</note>
        </member>
        <member name="M:ServiceStack.PrivateKeyBlob.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:ServiceStack.PublicKeyBlob">
            <summary>
            Public-key BLOBs, type PUBLICKEYBLOB, are used to store public keys outside a CSP. Extended provider public-key BLOBs have the following format.
            </summary>
        </member>
        <member name="F:ServiceStack.PublicKeyBlob.Header">
            <summary>
            BLOB Header
            </summary>
        </member>
        <member name="F:ServiceStack.PublicKeyBlob.RSAPubKey">
            <summary>
            RSA public key data
            </summary>
        </member>
        <member name="F:ServiceStack.PublicKeyBlob.Modulus">
            <summary>
            The public-key modulus data
            </summary>
        </member>
        <member name="M:ServiceStack.PublicKeyBlob.FromBinary(System.IO.BinaryReader)">
            <summary>
            Create and initialize structure from binary data
            </summary>
            <exception cref="T:ServiceStack.CryptographicException">On validate errors</exception>
            <returns>Initialized structure</returns>
        </member>
        <member name="M:ServiceStack.PublicKeyBlob.FromBinary(System.IO.BinaryReader,ServiceStack.BlobHeader)">
            <summary>
            Create and initialize structure from binary data with defined header
            </summary>
            <exception cref="T:ServiceStack.CryptographicException">On validate errors</exception>
            <returns>Initialized structure</returns>
        </member>
        <member name="M:ServiceStack.PublicKeyBlob.ToBinary(System.IO.BinaryWriter)">
            <summary>
            Serializes structure as binary data
            </summary>
        </member>
        <member name="M:ServiceStack.PublicKeyBlob.FromRSAParameters(ServiceStack.RSAParameters)">
            <summary>
            Create and initialize structure from RSAParameters
            </summary>
            <returns>Initialized structure</returns>
            <note>http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsaparameters.aspx</note>
        </member>
        <member name="M:ServiceStack.PublicKeyBlob.ToRSAParameters">
            <summary>
            Create and initialize RSAParameters structure
            </summary>
            <returns>Initialized structure</returns>
            <note>http://msdn.microsoft.com/en-us/library/system.security.cryptography.rsaparameters.aspx</note>
        </member>
        <member name="M:ServiceStack.PublicKeyBlob.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:ServiceStack.RSAParameters">
            <summary>
            RSAParameters for Import / Export
            </summary>
        </member>
        <member name="P:ServiceStack.RSAParameters.E">
            <summary>
            Parameter value E
            </summary>
        </member>
        <member name="P:ServiceStack.RSAParameters.N">
            <summary>
            Parameter value N
            </summary>
        </member>
        <member name="P:ServiceStack.RSAParameters.P">
            <summary>
            Parameter value P
            </summary>
        </member>
        <member name="P:ServiceStack.RSAParameters.Q">
            <summary>
            Parameter value Q
            </summary>
        </member>
        <member name="P:ServiceStack.RSAParameters.DP">
            <summary>
            Parameter value DP
            </summary>
        </member>
        <member name="P:ServiceStack.RSAParameters.DQ">
            <summary>
            Parameter value DQ
            </summary>
        </member>
        <member name="P:ServiceStack.RSAParameters.IQ">
            <summary>
            Parameter value IQ
            </summary>
        </member>
        <member name="P:ServiceStack.RSAParameters.D">
            <summary>
            Parameter value D
            </summary>
        </member>
        <member name="P:ServiceStack.RSAParameters.Phi">
            <summary>
            Parameter value Phi
            </summary>
        </member>
        <member name="M:ServiceStack.Mathematics.BitwiseXOR(System.Byte[],System.Byte[])">
            <summary>
            Bitwise XOR for 2 byte arrays.  Arrays must be the same length.
            </summary>
            <param name="t1">Left side for comparison</param>
            <param name="t2">Right side for comparison</param>
            <returns>Resulting byte array</returns>
        </member>
        <member name="M:ServiceStack.Mathematics.BitwiseXOR(System.Byte,System.Byte)">
            <summary>
            Bitwise XOR for 2 Bytes.
            </summary>
            <param name="t1">Left side for comparison</param>
            <param name="t2">Right side for comparison</param>
            <returns>Resulting byte</returns>
        </member>
        <member name="M:ServiceStack.Mathematics.I2OSP(System.Int32,System.Int32)">
            <summary>
            Convert the input Integer to an Octet String.
            </summary>
            <param name="x">input integer</param>
            <param name="size">size in octets (bytes)</param>
            <returns>Resulting byte array of specified length</returns>
        </member>
        <member name="M:ServiceStack.Mathematics.OAEPMGF(System.Byte[],System.Int32,System.Int32,ServiceStack.IHashProvider)">
            <summary>
            Mask generation function.
            </summary>
            <param name="seed">Seed</param>
            <param name="maskLen">Length of generated mask</param>
            <param name="hashLength">Length of the hash produced by the supplied hash provider</param>
            <param name="hashProvider">Hash provider to use in mask generation</param>
            <returns>Generated mask of specified length</returns>
        </member>
        <member name="F:ServiceStack.StreamExtensions.DefaultBufferSize">
            <summary>
            @jonskeet: Collection of utility methods which operate on streams.
            r285, February 26th 2009: http://www.yoda.arachsys.com/csharp/miscutil/
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadFully(System.IO.Stream)">
            <summary>
            Reads the given stream up to the end, returning the data as a byte
            array.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadFully(System.IO.Stream,System.Int32)">
            <summary>
            Reads the given stream up to the end, returning the data as a byte
            array, using the given buffer size.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadFully(System.IO.Stream,System.Byte[])">
            <summary>
            Reads the given stream up to the end, returning the data as a byte
            array, using the given buffer for transferring data. Note that the
            current contents of the buffer is ignored, so the buffer needn't
            be cleared beforehand.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Copies all the data from one stream into another.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            Copies all the data from one stream into another, using a buffer
            of the given size.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream,System.Byte[])">
            <summary>
            Copies all the data from one stream into another, using the given 
            buffer for transferring data. Note that the current contents of 
            the buffer is ignored, so the buffer needn't be cleared beforehand.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactly(System.IO.Stream,System.Int32)">
            <summary>
            Reads exactly the given number of bytes from the specified stream.
            If the end of the stream is reached before the specified amount
            of data is read, an exception is thrown.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactly(System.IO.Stream,System.Byte[])">
            <summary>
            Reads into a buffer, filling it completely.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactly(System.IO.Stream,System.Byte[],System.Int32)">
            <summary>
            Reads exactly the given number of bytes from the specified stream,
            into the given buffer, starting at position 0 of the array.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactly(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads exactly the given number of bytes from the specified stream,
            into the given buffer, starting at position 0 of the array.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactlyFast(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Same as ReadExactly, but without the argument checks.
            </summary>
        </member>
        <member name="M:ServiceStack.StringExtensions.BaseConvert(System.String,System.Int32,System.Int32)">
            <summary>
            Converts from base: 0 - 62
            </summary>
            <param name="source">The source.</param>
            <param name="from">From.</param>
            <param name="to">To.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.StringExtensions.FastToUtf8Bytes(System.String)">
            <summary>
            Skip the encoding process for 'safe strings' 
            </summary>
            <param name="strVal"></param>
            <returns></returns>
        </member>
    </members>
</doc>
